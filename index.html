<meta charset="utf-8" />

<!-- Router -->
<script>
  class Router {
    /**
     * @param {HTMLElement} rootElement
     */
    constructor(routes) {
      this.params = {};
      this.currentRoute = '';
      this.routes = {};
      this.titles = {};
      this.observers = [];
      this.setRoutes(routes);
      window.addEventListener('hashchange', () => {
        this.syncWithHash();
      });
    }
    /**
     * @param {string} route
     * One of the registered routes, without hashbang
     */
    navigateTo = route => {
      location.hash = `#!${route}`;
    };

    refresh = () => this.syncWithHash();

    // @possiblyNumber: string
    static isNumber(possiblyNumber) {
      return !isNaN(Number(possiblyNumber));
    }
    static isInt(possiblyInt) {
      return (
        Router.isNumber(possiblyInt) &&
        parseInt(possiblyInt) === Number(possiblyInt)
      );
    }
    static getTokens(hash) {
      return hash
        .split('/')
        .filter(Boolean)
        .filter(element => element !== '#')
        .filter(element => element !== '#!');
    }

    /**
     * @param {string} token
     * @returns {boolean}
     */
    static isParameterRouteToken(token) {
      if (
        token.indexOf('<') !== 0 ||
        !token.slice(2, -4).includes(':') ||
        token.indexOf('>') !== token.length - 1
      ) {
        return false;
      }
      const [parameter, type] = token
        .slice(token.indexOf('<') + 1, token.indexOf('>'))
        .split(':');

      if (!['int', 'string', 'number'].includes(type)) {
        return false;
      }
      return true;
    }
    static parseParameterRouteToken(token) {
      const [parameter, type] = token
        .slice(token.indexOf('<') + 1, token.indexOf('>'))
        .split(':');
      return {
        parameter,
        type,
      };
    }
    static appendTokenToHash(hash, token) {
      return `${hash}/${token}`;
    }
    // (hash: string, route: string) => false | { [key: string]: number | string }
    static getMatch(hash, route) {
      const hashTokens = Router.getTokens(hash);
      const routeTokens = Router.getTokens(route);
      const params = {};
      let reconstructedHash = '#!';
      if (hashTokens.length !== routeTokens.length) return false;
      for (let i of Object.keys(hashTokens)) {
        const hashToken = hashTokens[i];
        const routeToken = routeTokens[i];
        if (Router.isParameterRouteToken(routeToken)) {
          const { parameter, type } = Router.parseParameterRouteToken(
            routeToken
          );
          if (type === 'int') {
            if (!Router.isInt(hashToken)) return false;
            params[parameter] = parseInt(hashToken);
            reconstructedHash = Router.appendTokenToHash(
              reconstructedHash,
              hashToken
            );
          } else if (type === 'number' && !Router.isNumber(hasToken)) {
            if (!Router.isNumber(hashToken)) return false;
            params[parameter] = Number(hashToken);
            reconstructedHash = Router.appendTokenToHash(
              reconstructedHash,
              hashToken
            );
          } else if (type === 'string') {
            params[parameter] = hashToken;
            reconstructedHash = Router.appendTokenToHash(
              reconstructedHash,
              hashToken
            );
          }
        } else {
          if (hashToken !== routeToken) return false;
          reconstructedHash = Router.appendTokenToHash(
            reconstructedHash,
            hashToken
          );
        }
      }
      return { params, reconstructedHash };
    }
    static getRouteAndParamsFromHash(hash, routes) {
      for (let route of Object.keys(routes)) {
        const match = Router.getMatch(hash, route);
        if (match) {
          const { params, reconstructedHash } = match;
          return { route, params, reconstructedHash };
        }
      }
      return { route: '', params: {}, reconstructedHash: '' };
    }
    static removeHash() {
      return history.replaceState(null, null, ' ');
    }
    /**
     * @param {string} routes
     */
    setRoutes(routes) {
      Object.entries(routes).forEach(([route, title]) => {
        this.routes[route] = route;
        this.titles[route] = title;
        if (route === '/') {
          this.routes[''] = route;
          this.titles[''] = title;
        }
      });
      this.syncWithHash();
    }
    syncWithHash() {
      const { hash } = location;
      const {
        route,
        params,
        reconstructedHash,
      } = Router.getRouteAndParamsFromHash(hash, this.routes);
      this.setParams(params);
      this.setCurrentRoute(this.routes[route]);
      this.setCurrentTitle(this.titles[route]);
      if (reconstructedHash === '#!') {
        Router.removeHash();
      } else {
        location.hash = reconstructedHash;
      }
      document.title = this.currentTitle;
      this.emit();
    }
    /**
     * @param {Object.<string, number | string>} params
     */
    setParams(params) {
      this.params = params;
      // Todo: Maybe dispatch some kind of event
    }
    getParams = () => this.params;
    setCurrentRoute(route) {
      this.currentRoute = route;
    }
    getCurrentRoute = () => this.currentRoute;
    setCurrentTitle(title) {
      this.currentTitle = title;
    }
    getCurrentTitle = () => this.currentTitle;
    static isProp = propsOrChild =>
      !(
        propsOrChild instanceof HTMLElement || typeof propsOrChild === 'string'
      );

    /**
     * @param {function({ params: Object.<string, string | number> }): void} observer
     */
    subscribe = observer => {
      observer({
        currentRoute: this.currentRoute,
        params: this.params,
      });
      this.observers.push(observer);
    };

    // Rather than passing data, this one should pass a string saying which attribute has been updated
    emit() {
      this.observers.forEach(observer => {
        if (!observer)
          console.warn('Non-existing element registered as router observer');

        observer({ currentRoute: this.currentRoute, params: this.params });
      });
    }
  }
</script>

<!-- Utils -->
<script>
  const handleText = textOrNode =>
    typeof textOrNode === 'string'
      ? document.createTextNode(textOrNode)
      : textOrNode;

  const appendChild = (element, child) => {
    if (!child) return;
    element.appendChild(child);
  };

  const createElement = (elementType, ...children) => {
    const element = document.createElement(elementType);
    children.forEach(child => {
      const childNode = handleText(child);
      appendChild(element, childNode);
    });
    element._defaultUpdate = () =>
      element.childNodes.forEach(childNode => {
        if (typeof childNode.update !== 'function') return;
        childNode.update();
      });
    element.update = element._defaultUpdate;
    element.setStyle = styleObject => {
      Object.assign(element.style, styleObject);
      return element;
    };
    element.state = {};
    // initState is just like setState, except it does not call element.update
    element.initState = initialState => {
      Object.assign(element.state, initialState);
      return element;
    };
    element.initChildren = (...children) => {
      children.filter(Boolean).forEach(childOrFunction => {
        const child =
          typeof childOrFunction === 'function'
            ? childOrFunction(element)
            : childOrFunction;
        const childNode = handleText(child);
        appendChild(element, childNode);
      });
      return element;
    };
    element.setState = newState => {
      Object.assign(element.state, newState);
      element.update();
    };
    element.onUpdate = updateCallback => {
      element.update = () => {
        updateCallback(element);
        element._defaultUpdate();
      };
      return element;
    };
    element.onInput = inputCallback => {
      element.oninput = event => inputCallback(element, event);
      return element;
    };
    element.onMouseEnter = mouseEnterCallback => {
      element.onmouseenter = () => mouseEnterCallback(element);
      return element;
    };
    element.onMouseLeave = mouseLeaveCallback => {
      element.onmouseleave = () => mouseLeaveCallback(element);
      return element;
    };
    element.onClick = clickCallback => {
      element.onclick = () => clickCallback(element);
      return element;
    };
    return element;
  };

  const div = (...children) => createElement('div', ...children);
  const input = (...children) => createElement('input', ...children);
  const textArea = (...children) => createElement('textarea', ...children);
  const button = (...children) => createElement('button', ...children);

  // Might not need this
  const propsHaveChanged = (previousProps, newProps) => {
    for (key of Object.keys(previousProps)) {
      if (previousProps[key] !== newProps[key]) {
        return true;
      }
    }
    false;
  };

  // functionalComponent returns one node
  const Replaceable = functionalComponent =>
    div(functionalComponent()).onUpdate(element => {
      // TODO: Somehow make this not have to update if it doesn't have to
      // TODO: Accept that functionalComponent returns an array of hildren
      element.innerHTML = '';
      appendChild(element, functionalComponent());
    });

  // functionalComponent returns an array of nodes
  const Replaceables = functionalComponent =>
    div(...functionalComponent())
      .setStyle({ display: 'inline-block' })
      .onUpdate(element => {
        // TODO: Somehow make this not have to update if it doesn't have to
        // TODO: Accept that functionalComponent returns an array of hildren
        element.innerHTML = '';
        functionalComponent().forEach(child => appendChild(element, child));
      });

  const If = (fnCondition, fnThenComponent, fnElseComponent = () => null) => {
    const condition = fnCondition();
    return div(condition ? fnThenComponent() : fnElseComponent())
      .initState({ condition })
      .onUpdate(element => {
        const newCondition = fnCondition();
        if (newCondition === element.state.condition) return;
        element.setState({ condition: newCondition });
        element.innerHTML = '';
        appendChild(
          element,
          fnCondition()
            ? handleText(fnThenComponent())
            : handleText(fnElseComponent())
        );
      });
  };

  const Styled = (component, style) => (...children) =>
    component(...children).setStyle(style);
</script>

<!-- Components -->
<script>
  const TopNavigator = () => div().setStyle({ height: '40px' });

  const LeftNavigatorButton = ({ icon, label, route, isActive }) => {
    const Button = Styled(div, {
      height: '80px',
      width: '80px',
      overflow: 'hidden',
      transition: '0.25s',
      cursor: 'pointer',
    });
    const Icon = Styled(div, {
      fontSize: '30px',
      textAlign: 'center',
      marginTop: '15px',
      pointerEvents: 'none',
      userSelect: 'none',
    });
    const Label = Styled(div, {
      fontSize: '15px',
      textAlign: 'center',
      pointerEvents: 'none',
      userSelect: 'none',
    });
    return Button(Icon(icon), Label(label)).onUpdate(element => {
      element.style.background = isActive() ? 'WhiteSmoke' : 'initial';
      element.style.color = isActive() ? 'DimGray' : 'Gray';
      element.onmouseenter = () => {
        element.style.background = 'WhiteSmoke';
        element.style.color = 'DimGray';
      };
      element.onmouseleave = () => {
        element.style.background = isActive() ? 'WhiteSmoke' : 'initial';
        element.style.color = isActive() ? 'DimGray' : 'Gray';
      };
      element.onclick = () => {
        location.hash = `#!${route}`;
      };
    });
  };

  const LeftNavigator = (...children) =>
    div(...children).setStyle({
      height: '100%',
      width: '80px',
      borderRadius: '10px 0 0 0',
      borderRight: '1px solid LightGray',
      overflow: 'hidden',
      float: 'left',
      background: 'White',
    });

  const MainContainer = (...children) =>
    div(...children).setStyle({
      height: 'calc(100% - 40px)',
      borderRadius: '10px 10px 0 0',
      background: 'GhostWhite',
    });

  const HomeView = () => div('HomeView');

  const DataSourcesView = () => {
    const element = div('DataSourcesView');
    return element;
  };

  // Fake values stream
  const valuesStream = {
    observers: [],
    sourceValues: {
      valueA: 1000,
      valueB: 1000,
      valueC: 1000,
      valueD: 1000,
    },
    derivedValues: {
      'valueA + valueB': {
        dependsOn: { sourceValues: ['valueA', 'valueB'], derivedValues: [] },
        calculation: '({ valueA, valueB }) => valueA + valueB',
      },
    },
    setSourceValues: newSourceValues => {
      Object.assign(valuesStream.sourceValues, newSourceValues);
      valuesStream.emit();
    },
    setDerivedValues: newDerivedValues => {
      Object.assign(valuesStream.derivedValues, newDerivedValues);
      valuesStream.emit();
    },
    subscribe: observer => {
      observer({
        currentRoute: valuesStream.currentRoute,
        params: valuesStream.params,
      });
      valuesStream.observers.push(observer);
    },
    emit: () =>
      valuesStream.observers.forEach(observer => {
        observer();
      }),
  };
  // Regularly update dummy data
  const updateValuesStream = () =>
    setTimeout(() => {
      valuesStream.setSourceValues({
        valueA:
          Math.floor(Math.random() * 2) == 1
            ? valuesStream.sourceValues.valueA * 1.01
            : valuesStream.sourceValues.valueA / 1.01,
        valueB:
          Math.floor(Math.random() * 2) == 1
            ? valuesStream.sourceValues.valueB * 1.01
            : valuesStream.sourceValues.valueB / 1.01,
        valueC:
          Math.floor(Math.random() * 2) == 1
            ? valuesStream.sourceValues.valueC * 1.01
            : valuesStream.sourceValues.valueC / 1.01,
        valueD:
          Math.floor(Math.random() * 2) == 1
            ? valuesStream.sourceValues.valueD * 1.01
            : valuesStream.sourceValues.valueD / 1.01,
      });
      updateValuesStream();
    }, 100);
  setTimeout(updateValuesStream);

  const ValueBoxBox = Styled(div, {
    height: '160px',
    width: '240px',
    transition: '0.25s',
    display: 'inline-block',
    color: 'Gray',
    borderRight: '1px solid LightGray',
    boxSizing: 'border-box',
  });

  const ValueBoxLabel = fnLabel =>
    div(fnLabel())
      .setStyle({
        marginTop: '30px',
        fontSize: '30px',
        textAlign: 'center',
        pointerEvents: 'none',
        userSelect: 'none',
      })
      .onUpdate(element => {
        element.innerText = fnLabel();
      });

  const ValueBoxValue = ({ value }) =>
    div(value().toFixed(2))
      .setStyle({
        fontSize: '60px',
        textAlign: 'center',
        pointerEvents: 'none',
        userSelect: 'none',
      })
      .onUpdate(element => {
        element.innerText = value().toFixed(2);
      });

  const ValueBox = ({ value, label }) =>
    ValueBoxBox(ValueBoxLabel(label), ValueBoxValue({ value }));

  const NewValueBoxBox = Styled(div, {
    height: '160px',
    width: '240px',
    transition: '0.25s',
    display: 'inline-block',
    color: 'Gray',
    borderRight: '1px solid LightGray',
    cursor: 'pointer',
    boxSizing: 'border-box',
  });

  const NewValueBoxValue = ({ isHovered }) => {
    const element = Styled(div, {
      fontSize: '60px',
      textAlign: 'center',
      pointerEvents: 'none',
      userSelect: 'none',
      transition: '0.25s',
    })('+');
    element.update = () => {
      element.style.transform = `rotate(${isHovered() ? 90 : 0}deg)`;
    };
    return element;
  };
  const NewValueBox = ({ label }) =>
    NewValueBoxBox()
      .initState({ hovered: false })
      .initChildren(ValueBoxLabel(label), element =>
        NewValueBoxValue({
          isHovered: () => element.state.isHovered,
        })
      )
      .onMouseEnter(element => {
        element
          .setStyle({ background: 'WhiteSmoke', color: 'DimGray' })
          .setState({ isHovered: true });
      })
      .onMouseLeave(element => {
        element
          .setStyle({ background: 'initial', color: 'Gray' })
          .setState({ isHovered: false });
      });

  const calculateDerivedValue = (valuesStream, valueName) => {
    const { dependsOn, calculation } = valuesStream.derivedValues[valueName];
    return eval(
      `${
        Object.entries(valuesStream.sourceValues)
          .map(([name, value]) => `${name} = ${value};`)
          .join('') /* 'valueA = 4; valueB = 5;'*/
      }
          (${calculation})({${[
        ...Object.keys(
          valuesStream.sourceValues
        ) /* Here we should maybe for simplicity pass all arguments which are not the one we are calculating? */ /*,
        ...dependsOn.derivedValues,*/,
      ].join(', ')}})`
    );
  };

  const CodeEditor = ({ onSave }) =>
    div()
      .initState({ name: '', calculation: '' })
      .initChildren(
        element =>
          div(
            input()
              .setStyle({ width: '720px', height: '40px', fontSize: '20px' })
              .onInput((_, event) =>
                element.setState({ name: event.target.value })
              ),
            button('Save')
              .setStyle({
                background: 'CornflowerBlue',
                color: 'white',
                width: '240px',
                height: '40px',
                fontSize: '20px',
              })
              .onClick(() =>
                onSave({
                  [element.state.name]: {
                    calculation: element.state.calculation,
                  },
                })
              )
          ),
        element =>
          div(
            textArea()
              .setStyle({
                width: '960px',
                height: '240px',
              })
              .onInput((_, event) =>
                element.setState({ calculation: event.target.value })
              )
          )
      );

  const ValuesView = () => {
    const { sourceValues, derivedValues } = valuesStream;
    const element = div()
      .initState({ isEditingValue: false })
      .initChildren(
        element =>
          div(
            ValueBox({
              value: () => sourceValues.valueA,
              label: () => 'valueA',
            }),
            ValueBox({
              value: () => sourceValues.valueB,
              label: () => 'valueB',
            }),
            ValueBox({
              value: () => sourceValues.valueC,
              label: () => 'valueC',
            }),
            ValueBox({
              value: () => sourceValues.valueD,
              label: () => 'valueD',
            }),
            Replaceables(() =>
              Object.keys(derivedValues).map(key =>
                ValueBox({
                  value: () => calculateDerivedValue(valuesStream, key),
                  label: () => key,
                })
              )
            ),
            NewValueBox({
              label: () =>
                element.state.isEditingValue ? 'Cancel' : 'New value',
            }).onClick(() =>
              element.setState({
                isEditingValue: !element.state.isEditingValue,
              })
            )
          ),
        element =>
          div(
            If(
              () => element.state.isEditingValue,
              () =>
                CodeEditor({
                  onSave: derivedValue => {
                    valuesStream.setDerivedValues(derivedValue);
                    element.setState({ isEditingValue: false });
                  },
                })
            )
          )
      );
    valuesStream.subscribe(element.update);
    return element;
  };
  const AnalyticView = () => {
    const element = div('AnalyticsView');
    return element;
  };
  const AlertsView = () => {
    const element = div('AlertsView');
    return element;
  };

  class Observable {
    constructor(value) {
      // Maybe this can cause an id collision of two observables created almost at the same time
      this._id = `${Math.random()}${+new Date()}`;
      this._value = value;
    }
    emit() {
      window.dispatchEvent(
        new CustomEvent(this._id, {
          detail: this._value,
        })
      );
    }
    get id() {
      return this._id;
    }
    get value() {
      return this._value;
    }
    set value(value) {
      // Maybe this should do a deep compare in case value is an object?
      if (value === this._value) return;
      this._value = value;
      this.emit();
    }
  }

  const createElement$ = (elementType, ...observables) => {
    const element = document.createElement(elementType);
    observables.forEach(observable => {
      if (
        // If it is observable value
        observable instanceof Observable &&
        ['string', 'number'].includes(typeof observable.value)
      ) {
        const textNode = document.createTextNode(observable.value);
        element.appendChild(textNode);
        window.addEventListener(observable.id, ({ detail }) => {
          textNode.nodeValue = detail;
        });
        return;
      }
      if (
        // If it is non-observable value
        ['string', 'number'].includes(typeof observable)
      ) {
        const textNode = document.createTextNode(observable);
        element.appendChild(textNode);
        return;
      }
      // If it is a dom node
      element.appendChild(observable);
    });
    // Note that styleObject$ is an object with observable values, not an observable object
    // TODO: It should also be possible to set the style as a non-observable object
    element.setStyle = styleObject$ => {
      Object.entries(styleObject$).forEach(([styleProperty, styleValue$]) => {
        if (styleValue$ instanceof Observable) {
          element.style[styleProperty] = styleValue$.value;
          window.addEventListener(styleValue$.id, ({ detail }) => {
            element.style[styleProperty] = detail;
          });
          return;
        }
        element.style[styleProperty] = styleValue$;
      });
      return element;
    };
    element.onClick = clickCallback => {
      element.onclick = () => clickCallback(element);
      return element;
    };
    element.onMouseEnter = mouseEnterCallback => {
      element.onmouseenter = () => mouseEnterCallback(element);
      return element;
    };
    element.onMouseLeave = mouseLeaveCallback => {
      element.onmouseleave = () => mouseLeaveCallback(element);
      return element;
    };
    return element;
  };
  const div$ = (...children) => createElement$('div', ...children);
  const h1$ = (...children) => createElement$('h1', ...children);
  const canvas$ = ({ width, height }) => {
    const element = createElement('canvas');
    element.width = width;
    element.height = height;
    return element;
  };

  // Observable utils
  // Currently needs at least two arguments
  const add$ = (...observables) => {
    const sum = observables
      .map(observable =>
        observable instanceof Observable ? observable.value : observable
      )
      .reduce((a, b) => a + b);
    const sum$ = new Observable(sum);
    observables.forEach(observable => {
      window.addEventListener(observable.id, ({ detail }) => {
        const sum = observables
          .map(observable =>
            observable instanceof Observable ? observable.value : observable
          )
          .reduce((a, b) => a + b);
        sum$.value = sum;
      });
    });
    return sum$;
  };

  // Currently needs at least two arguments
  const subtract$ = (...observables) => {
    const difference = observables
      .map(observable =>
        observable instanceof Observable ? observable.value : observable
      )
      .reduce((a, b) => a + b);
    const difference$ = new Observable(difference);
    observables.forEach(observable => {
      window.addEventListener(observable.id, ({ detail }) => {
        const difference = observables
          .map(observable =>
            observable instanceof Observable ? observable.value : observable
          )
          .reduce((a, b) => a - b);
        difference$.value = difference;
      });
    });
    return difference$;
  };

  // Currently needs at least two arguments
  const multiply$ = (...observables) => {
    const product = observables
      .map(observable =>
        observable instanceof Observable ? observable.value : observable
      )
      .reduce((a, b) => a * b);
    const product$ = new Observable(product);
    observables.forEach(observable => {
      window.addEventListener(observable.id, ({ detail }) => {
        const product = observables
          .map(observable =>
            observable instanceof Observable ? observable.value : observable
          )
          .reduce((a, b) => a * b);
        product$.value = product;
      });
    });
    return product$;
  };

  // Currently needs at least two arguments
  const divide$ = (...observables) => {
    const quotient = observables
      .map(observable =>
        observable instanceof Observable ? observable.value : observable
      )
      .reduce((a, b) => a / b);
    const quotient$ = new Observable(quotient);
    observables.forEach(observable => {
      window.addEventListener(observable.id, ({ detail }) => {
        const quotient = observables
          .map(observable =>
            observable instanceof Observable ? observable.value : observable
          )
          .reduce((a, b) => a / b);
        quotient$.value = quotient;
      });
    });
    return quotient$;
  };

  const choose$ = (observable, option1, option2) => {
    const result$ = new Observable(
      (observable instanceof Observable
      ? observable.value
      : observable)
        ? option1 instanceof Observable
          ? option1.value
          : option1
        : option2 instanceof Observable
        ? option2.value
        : option2
    );
    [observable, option1, option2]
      .filter(observable => observable instanceof Observable)
      .forEach(observable => {
        window.addEventListener(observable.id, ({ detail }) => {
          // TODO: Make it possible to set a specific child of an observable
          result$.value = (observable instanceof Observable
          ? observable.value
          : observable)
            ? option1 instanceof Observable
              ? option1.value
              : option1
            : option2 instanceof Observable
            ? option2.value
            : option2;
        });
      });
    return result$;
  };

  // This is not used and can probably be removed
  const toArray$ = (...observables) => {
    const observableArray = observables.map(({ value }) => value);
    const array$ = new Observable(observableArray);
    observables.forEach((observable, i) => {
      window.addEventListener(observable.id, ({ detail }) => {
        // TODO: Make it possible to set a specific child of an observable
        array$.value = observables.map(({ value }) => value);
      });
    });
    return array$;
  };

  // Just a dummy observable
  const dashboardValue1$ = new Observable(100);
  const dashboardValue2$ = new Observable(100);
  const dashboardValue3$ = new Observable(100);
  const dashboardValue4$ = new Observable(100);
  const dashboardValue5$ = new Observable(100);
  const dashboardValue6$ = new Observable(100);
  const updateDashboardValue = () =>
    setTimeout(() => {
      const value1 = dashboardValue1$.value;
      const value2 = dashboardValue2$.value;
      const value3 = dashboardValue3$.value;
      const value4 = dashboardValue4$.value;
      const value5 = dashboardValue5$.value;
      const value6 = dashboardValue6$.value;
      dashboardValue1$.value =
        Math.floor(Math.random() * 2) == 1 ? value1 * 1.01 : value1 / 1.01;
      dashboardValue2$.value =
        Math.floor(Math.random() * 2) == 1 ? value2 * 1.01 : value2 / 1.01;
      dashboardValue3$.value =
        Math.floor(Math.random() * 2) == 1 ? value3 * 1.01 : value3 / 1.01;
      dashboardValue4$.value =
        Math.floor(Math.random() * 2) == 1 ? value4 * 1.01 : value4 / 1.01;
      dashboardValue5$.value =
        Math.floor(Math.random() * 2) == 1 ? value5 * 1.01 : value5 / 1.01;
      dashboardValue6$.value =
        Math.floor(Math.random() * 2) == 1 ? value6 * 1.01 : value6 / 1.01;
      updateDashboardValue();
    }, 100);
  updateDashboardValue();

  const dashboardValues$ = [
    dashboardValue1$,
    dashboardValue2$,
    dashboardValue3$,
    dashboardValue4$,
    dashboardValue5$,
    dashboardValue6$,
  ];

  const WidgetBackgroundContainer$ = (...children) =>
    div$(...children).setStyle({
      padding: '20px',
      width: '480px',
      height: '320px',
      display: 'inline-block',
      boxSizing: 'border-box',
      verticalAlign: 'top',
    });

  const WidgetForegroundContainer$ = (...children) =>
    div$(...children).setStyle({
      padding: '20px',
      height: '100%',
      border: '1px solid LightGray',
      boxSizing: 'border-box',
      background: 'White',
    });

  const WidgetInnerContainer$ = (...children) =>
    div$(...children).setStyle({
      width: '100%',
      height: '100%',
      display: 'flex',
    });

  // This is just experimental and does nothing relevant
  const Bar = ({ height$, maxHeight$ }) =>
    div$().setStyle({
      height: add$(multiply$(divide$(height$, maxHeight$), 100), '%'),
      maxHeight: '100%',
      background: 'LightGreen',
      flexGrow: '1',
      marginTop: 'auto',
      transition: '0.1s',
      margin: 'auto 10px 0 10px',
    });

  const BarChartWidget$ = ({ values$, maxValue$ }) =>
    WidgetBackgroundContainer$(
      WidgetForegroundContainer$(
        WidgetInnerContainer$(
          ...values$.map(value$ =>
            Bar({ height$: value$, maxHeight$: maxValue$ })
          )
        )
      )
    );

  /* Global app state */
  const state = new (function() {
    this.customDashboardWidgets = [
      new (function() {
        this.id = '0';
        this.vertices = [
          { x: 0, y: 0, z: 0 },
          { x: 0, y: 0, z: 100 },
          { x: 0, y: 100, z: 0 },
          { x: 100, y: 0, z: 0 },
        ];
        this.edges = [
          {
            color: 'blue',
            vertices: [this.vertices[0], this.vertices[1]],
            width: 2,
          },
          {
            color: 'blue',
            vertices: [this.vertices[0], this.vertices[2]],
            width: 2,
          },
          {
            color: 'blue',
            vertices: [this.vertices[0], this.vertices[3]],
            width: 2,
          },
          {
            color: 'blue',
            vertices: [this.vertices[1], this.vertices[2]],
            width: 2,
          },
          {
            color: 'blue',
            vertices: [this.vertices[1], this.vertices[3]],
            width: 2,
          },
          {
            color: 'blue',
            vertices: [this.vertices[2], this.vertices[3]],
            width: 2,
          },
        ];
        this.faces = [
          {
            color: 'rgba(128, 128, 255, 0.5)',
            vertices: [this.vertices[0], this.vertices[1], this.vertices[2]],
          },
          {
            color: 'rgba(128, 128, 255, 0.5)',
            vertices: [this.vertices[0], this.vertices[1], this.vertices[3]],
          },
          {
            color: 'rgba(128, 128, 255, 0.5)',
            vertices: [this.vertices[1], this.vertices[2], this.vertices[3]],
          },
          {
            color: 'rgba(128, 128, 255, 0.5)',
            vertices: [this.vertices[0], this.vertices[2], this.vertices[3]],
          },
        ];
      })(),
      new (function() {
        this.id = '1';
        this.vertices = [
          { x: 0, y: 0, z: 0 },
          { x: 0, y: 0, z: 100 },
          { x: 0, y: 100, z: 0 },
          { x: 100, y: 0, z: 0 },
        ];
        this.edges = [
          {
            color: 'red',
            vertices: [this.vertices[0], this.vertices[1]],
            width: 2,
          },
          {
            color: 'red',
            vertices: [this.vertices[0], this.vertices[2]],
            width: 2,
          },
          {
            color: 'red',
            vertices: [this.vertices[0], this.vertices[3]],
            width: 2,
          },
          {
            color: 'red',
            vertices: [this.vertices[1], this.vertices[2]],
            width: 2,
          },
          {
            color: 'red',
            vertices: [this.vertices[1], this.vertices[3]],
            width: 2,
          },
          {
            color: 'red',
            vertices: [this.vertices[2], this.vertices[3]],
            width: 2,
          },
        ];
        this.faces = [
          {
            color: 'rgba(255, 128, 128, 0.5)',
            vertices: [this.vertices[0], this.vertices[1], this.vertices[2]],
          },
          {
            color: 'rgba(255, 128, 128, 0.5)',
            vertices: [this.vertices[0], this.vertices[1], this.vertices[3]],
          },
          {
            color: 'rgba(255, 128, 128, 0.5)',
            vertices: [this.vertices[1], this.vertices[2], this.vertices[3]],
          },
          {
            color: 'rgba(255, 128, 128, 0.5)',
            vertices: [this.vertices[0], this.vertices[2], this.vertices[3]],
          },
        ];
      })(),
    ];
    this.createNewCustomDashboardWidget = () => {
      const id = `${Math.random()}${+new Date()}`;
      this.customDashboardWidgets.push({
        id,
        vertices: [],
        edges: [],
        faces: [],
      });
      return id;
    };
    this.deleteCustomDashboardWidgetById = id => {
      this.customDashboardWidgets = this.customDashboardWidgets.filter(
        structure => structure.id !== id
      );
    };
  })();

  const rotate = (vertex, rx, ry) => {
    const theta = rx;
    const phi = ry;

    const horizontallyRotatedVertex = {
      x: vertex.x * Math.cos(theta) + vertex.z * Math.sin(theta),
      y: vertex.y,
      z: vertex.z * Math.cos(theta) - vertex.x * Math.sin(theta),
    };

    return {
      x: horizontallyRotatedVertex.x,
      y:
        horizontallyRotatedVertex.y * Math.cos(phi) -
        horizontallyRotatedVertex.z * Math.sin(phi),
      z:
        horizontallyRotatedVertex.y * Math.sin(phi) +
        horizontallyRotatedVertex.z * Math.cos(phi),
    };
  };

  const toCenterOfWidget = (vertex, ctx) => ({
    x: vertex.x + ctx.canvas.width / 2,
    y: vertex.y - ctx.canvas.height / 2,
    z: vertex.z,
  });

  const toPerspective = (vertex, d, focalLength) => ({
    x: vertex.x * (focalLength / (d + focalLength + vertex.z)),
    y: vertex.y * (focalLength / (d + focalLength + vertex.z)),
    z: vertex.z,
  });

  /**
   * @param {number} dx
   * Defines the x coordinate which will be displayed in the center of the
   * visualization
   *
   * @param {number} dy
   * Defines the y coordinate which will be displayed in the center of the
   * visualization
   *
   * @param {number} dz
   * Defines the z coordinate which will be displayed in the center of the
   * visualization
   *
   * @param {number} d
   * Defines the distance from the defined center of the structure, to the
   * camera.
   */
  const render = (structure, ctx, center, rx, ry, d, focalLength) => {
    // Render the faces
    structure.faces.forEach(({ color, vertices }) => {
      vertices
        .map(vertex => rotate(vertex, rx, ry))
        .map(vertex => toPerspective(vertex, d, focalLength))
        .map(vertex => toCenterOfWidget(vertex, ctx))
        .forEach((vertex, index) => {
          if (index === 0) {
            ctx.beginPath();
            ctx.moveTo(vertex.x, -vertex.y);
            return;
          }
          if (index < vertices.length - 1) {
            ctx.lineTo(vertex.x, -vertex.y);
            return;
          }
          if (index === vertices.length - 1) {
            ctx.lineTo(vertex.x, -vertex.y);
            ctx.closePath();
            ctx.fillStyle = color;
            ctx.fill();
            return;
          }
        });
    });

    // Render the edges
    structure.edges.forEach(({ color, vertices, width }) => {
      // Draw the first vertex
      const startVertex = toCenterOfWidget(
        toPerspective(rotate(vertices[0], rx, ry), d, focalLength),
        ctx
      );
      const endVertex = toCenterOfWidget(
        toPerspective(rotate(vertices[1], rx, ry), d, focalLength),
        ctx
      );
      ctx.beginPath();
      ctx.lineCap = 'round';
      ctx.moveTo(startVertex.x, -startVertex.y);
      ctx.lineTo(endVertex.x, -endVertex.y);
      ctx.lineWidth = width;
      ctx.strokeStyle = color;
      ctx.stroke();
    });
  };

  const Camera = function({
    target = { x: 0, y: 0, z: 0 },
    horizontalRotation = 0,
    verticalRotation = 0,
    distance = 100,
    focalLength = 1000,
  }) {
    this.target = target;
    this.horizontalRotation = new Observable(horizontalRotation);
    this.verticalRotation = new Observable(
      Math.max(Math.min(verticalRotation, Math.PI / 4), -Math.PI / 2)
    );
    this.distance = new Observable(Math.max(distance, -focalLength / 2));
    this.focalLength = focalLength;
    this.setDistance = distance => {
      this.distance.value = Math.max(distance, -focalLength / 2);
    };
    this.setVerticalRotation = verticalRotation => {
      this.verticalRotation.value = Math.max(
        Math.min(verticalRotation, Math.PI / 2),
        -Math.PI / 2
      );
    };
  };

  const ThreeDimVisualization$ = ({ structure }) => {
    const state = { mouseDown: false };
    const canvas = canvas$({ height: 240, width: 400 });
    const camera = new Camera({
      target: { x: 0, y: 0, z: 0 },
      horizontalRotation: 0,
      verticalRotation: 0,
      distance: 100,
      focalLength: 1000,
    });
    const ctx = canvas.getContext('2d');
    const rerender = () =>
      render(
        structure,
        ctx,
        camera.target,
        camera.horizontalRotation.value,
        camera.verticalRotation.value,
        camera.distance.value,
        camera.focalLength
      );
    rerender();
    canvas.onwheel = event => {
      camera.setDistance(camera.distance.value + event.deltaY);
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      rerender();
    };
    window.addEventListener('mousedown', event => {
      state.mouseDown = true;
    });
    window.addEventListener(
      'mouseup',
      (canvas.onmouseup = event => {
        state.mouseDown = false;
      })
    );
    canvas.onmousemove = event => {
      if (state.mouseDown) {
        camera.horizontalRotation.value =
          camera.horizontalRotation.value + event.movementX / 100;
        camera.setVerticalRotation(
          camera.verticalRotation.value + event.movementY / 100
        );
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        rerender();
      }
    };
    window.addEventListener(camera.horizontalRotation.id, () => {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      rerender();
    });
    window.addEventListener(camera.verticalRotation.id, ({ detail }) => {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      rerender();
    });
    return canvas;
  };

  const icon$ = ({ icon, onClick, isVisible }) =>
    div$(icon).setStyle({
      position: 'relative',
      bottom: '20px',
      opacity: choose$(isVisible, '1', '0'),
      float: 'right',
      cursor: 'pointer',
      marginLeft: '10px',
      userSelect: 'none',
      transition: '0.25s',
    });

  const CanvasWidget$ = ({ structure }) => {
    const isVisible = new Observable(false);
    return WidgetBackgroundContainer$(
      WidgetForegroundContainer$(
        ThreeDimVisualization$({ structure }),
        icon$({ icon: '🗑️', isVisible }).onClick(() => {
          state.deleteCustomDashboardWidgetById(structure.id);
          location.hash = '#!/dashboards';
        }),
        icon$({
          icon: '✏️',
          isVisible,
        }).onClick(() => {
          location.hash = `#!/dashboards/${structure.id}/edit`;
        })
      )
        .onMouseEnter(element => {
          isVisible.value = true;
        })
        .onMouseLeave(element => {
          isVisible.value = false;
        })
    );
  };

  const AddNewWidget = () => {
    const isHovered = new Observable(false);
    return WidgetBackgroundContainer$(
      WidgetForegroundContainer$(
        div$('+').setStyle({
          fontSize: '60px',
          textAlign: 'center',
          lineHeight: '240px',
          pointerEvents: 'none',
          userSelect: 'none',
          color: choose$(isHovered, 'DimGray', 'Gray'),
          transition: '0.25s',
          transform: choose$(isHovered, 'rotate(90deg)', 'rotate(0deg)'),
        })
      )
        .setStyle({
          cursor: 'pointer',
        })
        .onMouseEnter(element => {
          isHovered.value = true;
        })
        .onMouseLeave(element => {
          isHovered.value = false;
        })
    );
  };

  const DashboardsView = () => {
    const title$ = new Observable('Dashboards');
    const count1$ = new Observable(1);
    const count2$ = new Observable(2);
    const count$ = add$(count1$, count2$);
    const element = div$(count$);
    element.onclick = () => {
      count1$.value = count1$.value + 1;
      count2$.value = count1$.value + 1;
      title$.value = title$.value.toLowerCase();
    };
    return div$(
      BarChartWidget$({
        values$: dashboardValues$,
        maxValue$: new Observable(200),
      }),
      ...state.customDashboardWidgets.map(structure =>
        CanvasWidget$({ structure })
      ),
      AddNewWidget().onClick(() => {
        const idOfNewStructure = state.createNewCustomDashboardWidget();
        location.hash = `#!/dashboards/${idOfNewStructure}/edit`;
      })
    );
  };

  const RightNavigator$ = (...children) =>
    div$(...children).setStyle({
      height: '100%',
      width: '480px',
      borderRadius: '0 10px 0 0',
      borderLeft: '1px solid LightGray',
      overflow: 'hidden',
      float: 'right',
      background: 'White',
    });

  const RightNavigatorHeader$ = (...children) =>
    div$(...children).setStyle({
      height: '80px',
      borderBottom: '1px solid lightGray',
    });

  const RightNavigatorButton = ({ icon, label, isActive }) => {
    const Button = Styled(div, {
      height: '80px',
      width: '80px',
      overflow: 'hidden',
      transition: '0.25s',
      cursor: 'pointer',
    });
    const Icon = Styled(div, {
      fontSize: '30px',
      textAlign: 'center',
      marginTop: '15px',
      pointerEvents: 'none',
      userSelect: 'none',
    });
    const Label = Styled(div, {
      fontSize: '15px',
      textAlign: 'center',
      pointerEvents: 'none',
      userSelect: 'none',
    });
    return Button(Icon(icon), Label(label)).onUpdate(element => {
      element.style.background = isActive() ? 'WhiteSmoke' : 'initial';
      element.style.color = isActive() ? 'DimGray' : 'Gray';
      element.onmouseenter = () => {
        element.style.background = 'WhiteSmoke';
        element.style.color = 'DimGray';
      };
      element.onmouseleave = () => {
        element.style.background = isActive() ? 'WhiteSmoke' : 'initial';
        element.style.color = isActive() ? 'DimGray' : 'Gray';
      };
      element.onclick = () => {
        //location.hash = `#!${route}`;
      };
    });
  };

  const EditWidgetView = ({ widgetId }) => {
    const rightNavigatorTap = new Observable('Edges');
    return div$(
      RightNavigator$(
        RightNavigatorHeader$(
          RightNavigatorButton({
            icon: '📏',
            label: 'Edges',
            isActive: () => true,
          })
        )
      ),
      CanvasWidget$({
        structure: state.customDashboardWidgets.find(
          widget => widget.id === widgetId
        ),
      })
    );
  };

  const App = ({ params, currentRoute }) => {
    const element = div(
      TopNavigator(),
      MainContainer(
        LeftNavigator(
          // Add something for home as well
          LeftNavigatorButton({
            icon: '🏗',
            label: 'Data sources',
            route: '/data-sources',
            isActive: () => currentRoute() === '/data-sources',
          }),
          LeftNavigatorButton({
            icon: '🧮',
            label: 'Values',
            route: '/values',
            isActive: () => currentRoute() === '/values',
          }),
          LeftNavigatorButton({
            icon: '📊',
            label: 'Dashboards',
            route: '/dashboards',
            isActive: () =>
              ['/dashboards', '/dashboards/<widgetId:string>/edit'].includes(
                currentRoute()
              ),
          }),
          LeftNavigatorButton({
            icon: '⏰',
            label: 'Alerts',
            route: '/alerts',
            isActive: () => currentRoute() === '/alerts',
          })
        ),
        // Not sure I'm happy about this solution
        Replaceable(() => {
          if (currentRoute() === '/') return HomeView();
          if (currentRoute() === '/data-sources') return DataSourcesView();
          if (currentRoute() === '/values') return ValuesView();
          if (currentRoute() === '/dashboards') return DashboardsView();
          if (currentRoute() === '/dashboards/<widgetId:string>/edit')
            return EditWidgetView({ widgetId: params().widgetId });
          if (currentRoute() === '/alerts') return AlertsView();
          if (currentRoute() === '/analytics/<analyticId:string>')
            return AnalyticView();
          return 'Route does not exist';
        })
      )
    );

    return element;
  };
</script>

<script>
  window.onload = () => {
    Object.assign(document.body.style, {
      background: 'black',
      margin: 0,
      height: '100%',
    });
    //const FIREBASE_API_KEY = 'AIzaSyCeGXLqw0MEwiSFHG1Wks1HfQHXRZoOuFY';

    // Create router
    const router = new Router({
      '/': 'Home',
      '/data-sources': 'Data sources',
      '/values': 'Values',
      '/analytics/<analyticId:string>': 'Analytics',
      // TODO: It should be possible to have multiple dashboards
      '/dashboards': 'Dashboards',
      '/dashboards/<widgetId:string>/edit': 'Edit widget',
      '/alerts': 'Alerts',
    });

    document.body.appendChild(
      App({ params: router.getParams, currentRoute: router.getCurrentRoute })
    );
    document.body.update = props =>
      document.body.childNodes.forEach(childNode => {
        if (typeof childNode.update === 'function') {
          childNode.update(props);
        }
      });

    router.subscribe(() => document.body.update());
  };
</script>
