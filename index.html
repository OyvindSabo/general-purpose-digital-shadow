<!-- Router -->
<script>
  class Router {
    /**
     * @param {HTMLElement} rootElement
     */
    constructor(routes) {
      this.params = {};
      this.currentRoute = '';
      this.routes = {};
      this.titles = {};
      this.observers = [];
      this.setRoutes(routes);
      window.addEventListener('hashchange', () => {
        this.syncWithHash();
      });
    }
    /**
     * @param {string} route
     * One of the registered routes, without hashbang
     */
    navigateTo = route => {
      location.hash = `#!${route}`;
    };

    refresh = () => this.syncWithHash();

    // @possiblyNumber: string
    static isNumber(possiblyNumber) {
      return !isNaN(Number(possiblyNumber));
    }
    static isInt(possiblyInt) {
      return (
        Router.isNumber(possiblyInt) &&
        parseInt(possiblyInt) === Number(possiblyInt)
      );
    }
    static getTokens(hash) {
      return hash
        .split('/')
        .filter(Boolean)
        .filter(element => element !== '#')
        .filter(element => element !== '#!');
    }

    /**
     * @param {string} token
     * @returns {boolean}
     */
    static isParameterRouteToken(token) {
      if (
        token.indexOf('<') !== 0 ||
        !token.slice(2, -4).includes(':') ||
        token.indexOf('>') !== token.length - 1
      ) {
        return false;
      }
      const [parameter, type] = token
        .slice(token.indexOf('<') + 1, token.indexOf('>'))
        .split(':');

      if (!['int', 'string', 'number'].includes(type)) {
        return false;
      }
      return true;
    }
    static parseParameterRouteToken(token) {
      const [parameter, type] = token
        .slice(token.indexOf('<') + 1, token.indexOf('>'))
        .split(':');
      return {
        parameter,
        type,
      };
    }
    static appendTokenToHash(hash, token) {
      return `${hash}/${token}`;
    }
    // (hash: string, route: string) => false | { [key: string]: number | string }
    static getMatch(hash, route) {
      const hashTokens = Router.getTokens(hash);
      const routeTokens = Router.getTokens(route);
      const params = {};
      let reconstructedHash = '#!';
      if (hashTokens.length !== routeTokens.length) return false;
      for (let i of Object.keys(hashTokens)) {
        const hashToken = hashTokens[i];
        const routeToken = routeTokens[i];
        if (Router.isParameterRouteToken(routeToken)) {
          const { parameter, type } = Router.parseParameterRouteToken(
            routeToken
          );
          if (type === 'int') {
            if (!Router.isInt(hashToken)) return false;
            params[parameter] = parseInt(hashToken);
            reconstructedHash = Router.appendTokenToHash(
              reconstructedHash,
              hashToken
            );
          } else if (type === 'number' && !Router.isNumber(hasToken)) {
            if (!Router.isNumber(hashToken)) return false;
            params[parameter] = Number(hashToken);
            reconstructedHash = Router.appendTokenToHash(
              reconstructedHash,
              hashToken
            );
          } else if (type === 'string') {
            params[parameter] = hashToken;
            reconstructedHash = Router.appendTokenToHash(
              reconstructedHash,
              hashToken
            );
          }
        } else {
          if (hashToken !== routeToken) return false;
          reconstructedHash = Router.appendTokenToHash(
            reconstructedHash,
            hashToken
          );
        }
      }
      return { params, reconstructedHash };
    }
    static getRouteAndParamsFromHash(hash, routes) {
      for (let route of Object.keys(routes)) {
        const match = Router.getMatch(hash, route);
        if (match) {
          const { params, reconstructedHash } = match;
          return { route, params, reconstructedHash };
        }
      }
      return { route: '', params: {}, reconstructedHash: '' };
    }
    static removeHash() {
      return history.replaceState(null, null, ' ');
    }
    /**
     * @param {string} routes
     */
    setRoutes(routes) {
      Object.entries(routes).forEach(([route, title]) => {
        this.routes[route] = route;
        this.titles[route] = title;
        if (route === '/') {
          this.routes[''] = route;
          this.titles[''] = title;
        }
      });
      this.syncWithHash();
    }
    syncWithHash() {
      const { hash } = location;
      const {
        route,
        params,
        reconstructedHash,
      } = Router.getRouteAndParamsFromHash(hash, this.routes);
      this.setParams(params);
      this.setCurrentRoute(this.routes[route]);
      this.setCurrentTitle(this.titles[route]);
      if (reconstructedHash === '#!') {
        Router.removeHash();
      } else {
        location.hash = reconstructedHash;
      }
      document.title = this.currentTitle;
      this.emit();
    }
    /**
     * @param {Object.<string, number | string>} params
     */
    setParams(params) {
      this.params = params;
      // Todo: Maybe dispatch some kind of event
    }
    getParams = () => this.params;
    setCurrentRoute(route) {
      this.currentRoute = route;
    }
    getCurrentRoute = () => this.currentRoute;
    setCurrentTitle(title) {
      this.currentTitle = title;
    }
    getCurrentTitle = () => this.currentTitle;
    static isProp = propsOrChild =>
      !(
        propsOrChild instanceof HTMLElement || typeof propsOrChild === 'string'
      );

    /**
     * @param {function({ params: Object.<string, string | number> }): void} observer
     */
    subscribe = observer => {
      observer({
        currentRoute: this.currentRoute,
        params: this.params,
      });
      this.observers.push(observer);
    };

    // Rather than passing data, this one should pass a string saying which attribute has been updated
    emit() {
      this.observers.forEach(observer => {
        if (!observer)
          console.warn('Non-existing element registered as router observer');

        observer({ currentRoute: this.currentRoute, params: this.params });
      });
    }
  }
</script>

<!-- Utils -->
<script>
  const div = (...children) => {
    const element = document.createElement('div');
    children.forEach(child => {
      element.appendChild(child);
    });
    element.update = props =>
      element.childNodes.forEach(childNode => {
        if (typeof childNode.update !== 'function') return;
        childNode.update(props);
      });
    return element;
  };

  const text = value => document.createTextNode(value);

  // Might not need this
  const propsHaveChanged = (previousProps, newProps) => {
    for (key of Object.keys(previousProps)) {
      if (previousProps[key] !== newProps[key]) {
        return true;
      }
    }
    false;
  };

  const Replaceable = functionalComponent => {
    const element = div(functionalComponent());
    element.update = () => {
      // TODO: Somehow make this not have to update if it doesn't have to
      // TODO: Accept that functionalComponent returns an array of hildren
      element.innerHTML = '';
      element.appendChild(functionalComponent());
    };
    return element;
  };

  const Styled = (component, style) => (...children) => {
    const element = component(...children);
    Object.assign(element.style, style);
    return element;
  };
</script>

<!-- Components -->
<script>
  const TopNavigator = () => {
    const navigator = div();
    Object.assign(navigator.style, {
      height: '40px',
    });
    return navigator;
  };
  const LeftNavigatorButton = ({ icon, label, route, isActive }) => {
    const Button = Styled(div, {
      height: '80px',
      width: '80px',
      overflow: 'hidden',
      transition: '0.25s',
    });
    const Icon = Styled(div, {
      fontSize: '30px',
      textAlign: 'center',
      marginTop: '15px',
      pointerEvents: 'none',
      userSelect: 'none',
    });
    const Label = Styled(div, {
      fontSize: '15px',
      textAlign: 'center',
      pointerEvents: 'none',
      userSelect: 'none',
    });
    const element = Button(Icon(text(icon)), Label(text(label)));

    element.render = () => {
      element.style.background = isActive() ? 'WhiteSmoke' : 'initial';
      element.style.color = isActive() ? 'DimGray' : 'Gray';
      element.onmouseenter = () => {
        element.style.background = 'WhiteSmoke';
        element.style.color = 'DimGray';
      };
      element.onmouseleave = () => {
        element.style.background = isActive() ? 'WhiteSmoke' : 'initial';
        element.style.color = isActive() ? 'DimGray' : 'Gray';
      };
      element.onclick = () => {
        location.hash = `#!${route}`;
      };
    };
    element.update = element.render;
    return element;
  };

  const LeftNavigator = (...children) => {
    const leftNavigator = div(...children);
    Object.assign(leftNavigator.style, {
      height: '100%',
      width: '80px',
      borderRadius: '10px 0 0 0',
      borderRight: '2px solid WhiteSmoke',
      overflow: 'hidden',
      float: 'left',
    });
    return leftNavigator;
  };

  const MainContainer = (...children) => {
    const mainContainer = div(...children);
    Object.assign(mainContainer.style, {
      height: 'calc(100% - 40px)',
      borderRadius: '10px 10px 0 0',
      background: 'white',
    });
    return mainContainer;
  };

  const HomeView = () => {
    const homeView = div();
    homeView.appendChild(TopNavigator());
    homeView.appendChild(MainContainer());
    homeView.appendChild(text('HomeView'));
    return homeView;
  };
  const DataSourcesView = () => {
    const element = div(text('DataSourcesView'));
    return element;
  };
  // Fake values stream
  const valuesStream = {
    observers: [],
    sourceValues: {
      valueA: 1000,
      valueB: 1000,
      valueC: 1000,
      valueD: 1000,
    },
    setSourceValues: newSourceValues => {
      Object.assign(valuesStream.sourceValues, newSourceValues);
      valuesStream.emit();
    },
    subscribe: observer => {
      observer({
        currentRoute: valuesStream.currentRoute,
        params: valuesStream.params,
      });
      valuesStream.observers.push(observer);
    },
    emit: () =>
      valuesStream.observers.forEach(observer => {
        observer();
      }),
  };
  // Regularly update dummy data
  const updateValuesStream = () =>
    setTimeout(() => {
      valuesStream.setSourceValues({
        valueA:
          Math.floor(Math.random() * 2) == 1
            ? valuesStream.sourceValues.valueA * 1.01
            : valuesStream.sourceValues.valueA / 1.01,
        valueB:
          Math.floor(Math.random() * 2) == 1
            ? valuesStream.sourceValues.valueB * 1.01
            : valuesStream.sourceValues.valueB / 1.01,
        valueC:
          Math.floor(Math.random() * 2) == 1
            ? valuesStream.sourceValues.valueC * 1.01
            : valuesStream.sourceValues.valueC / 1.01,
        valueD:
          Math.floor(Math.random() * 2) == 1
            ? valuesStream.sourceValues.valueD * 1.01
            : valuesStream.sourceValues.valueD / 1.01,
      });
      updateValuesStream();
    }, 100);
  setTimeout(updateValuesStream);

  const ValueBoxBox = Styled(div, {
    height: '160px',
    width: '240px',
    overflow: 'hidden',
    transition: '0.25s',
    float: 'left',
    color: 'Gray',
    borderRight: '2px solid WhiteSmoke',
  });

  const ValueBoxLabel = Styled(div, {
    marginTop: '30px',
    fontSize: '30px',
    textAlign: 'center',
    pointerEvents: 'none',
    userSelect: 'none',
  });
  const ValueBoxValue = ({ value }) => {
    const element = Styled(div, {
      fontSize: '60px',
      textAlign: 'center',
      pointerEvents: 'none',
      userSelect: 'none',
    })(text(value().toFixed(2)));
    element.update = () => (element.innerText = value().toFixed(2));
    return element;
  };
  const ValueBox = ({ value, label }) => {
    const element = ValueBoxBox(
      ValueBoxLabel(text(label())),
      ValueBoxValue({ value })
    );
    return element;
  };
  const ValuesView = () => {
    const sourceValues = valuesStream.sourceValues;
    const element = div(
      text('ValuesView'),
      ValueBox({ value: () => sourceValues.valueA, label: () => 'valueA' }),
      ValueBox({ value: () => sourceValues.valueB, label: () => 'valueB' }),
      ValueBox({ value: () => sourceValues.valueC, label: () => 'valueC' }),
      ValueBox({ value: () => sourceValues.valueD, label: () => 'valueD' })
    );
    valuesStream.subscribe(element.update);
    return element;
  };
  const AnalyticView = () => {
    const element = div(text('AnalyticsView'));
    return element;
  };
  const AlertsView = () => {
    const element = div(text('AlertsView'));
    return element;
  };
  const DashboardsView = () => {
    const element = div(text('DashboardsView'));
    return element;
  };
  const App = ({ params, currentRoute }) => {
    const element = div(
      TopNavigator(),
      MainContainer(
        LeftNavigator(
          LeftNavigatorButton({
            icon: 'ðŸ—',
            label: 'Data sources',
            route: '/data-sources',
            isActive: () => currentRoute() === '/data-sources',
          }),
          LeftNavigatorButton({
            icon: 'ðŸ§®',
            label: 'Values',
            route: '/values',
            isActive: () => currentRoute() === '/values',
          }),
          LeftNavigatorButton({
            icon: 'ðŸ“Š',
            label: 'Dashboards',
            route: '/dashboards',
            isActive: () => currentRoute() === '/dashboards',
          }),
          LeftNavigatorButton({
            icon: 'â°',
            label: 'Alerts',
            route: '/alerts',
            isActive: () => currentRoute() === '/alerts',
          })
        ),
        // Not sure I'm happy about this solution
        Replaceable(() => {
          if (currentRoute() === '/') return HomeView();
          if (currentRoute() === '/data-sources') return DataSourcesView();
          if (currentRoute() === '/values') return ValuesView();
          if (currentRoute() === '/dashboards') return DashboardsView();
          if (currentRoute() === '/alerts') return AlertsView();
          if (currentRoute() === '/analytics/<analyticId:string>')
            return AnalyticView();
          return document.createTextNode('Route does not exist');
        })
      )
    );

    return element;
  };
</script>

<script>
  window.onload = () => {
    Object.assign(document.body.style, {
      background: 'black',
      margin: 0,
      height: '100%',
    });
    //const FIREBASE_API_KEY = 'AIzaSyCeGXLqw0MEwiSFHG1Wks1HfQHXRZoOuFY';

    // Create router
    const router = new Router({
      '/': 'Home',
      '/data-sources': 'Data sources',
      '/values': 'Values',
      '/analytics/<analyticId:string>': 'Analytics',
      '/dashboards': 'Dashboards',
      '/alerts': 'Alerts',
    });

    document.body.appendChild(
      App({ params: router.getParams, currentRoute: router.getCurrentRoute })
    );
    document.body.update = props =>
      document.body.childNodes.forEach(childNode => {
        if (typeof childNode.update === 'function') {
          childNode.update(props);
        }
      });

    router.subscribe(() => document.body.update());
  };
</script>
