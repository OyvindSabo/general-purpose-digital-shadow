
<meta charset="utf-8" />
<script>
const modules = {}
const include = path => modules[path];

modules['src/libraries/simpleRouter/SimpleRouter.js'] = (() => {
  const module = { exports: {} };
  function SimpleRouter(routes) {
  /**
   * @param {string} routes
   */
  this.setRoutes = function (routes) {
    Object.entries(routes).forEach(([route, title]) => {
      this.routes[route] = route;
      this.titles[route] = title;
      if (route === '/') {
        this.routes[''] = route;
        this.titles[''] = title;
      }
    });
    this.syncWithHash();
  };
  SimpleRouter.getTokens = function (hash) {
    return hash
      .split('/')
      .filter(Boolean)
      .filter((element) => element !== '#')
      .filter((element) => element !== '#!');
  };
  /**
   * @param {string} token
   * @returns {boolean}
   */
  SimpleRouter.isParameterRouteToken = function (token) {
    if (
      token.indexOf('<') !== 0 ||
      !token.slice(2, -4).includes(':') ||
      token.indexOf('>') !== token.length - 1
    ) {
      return false;
    }
    const [parameter, type] = token
      .slice(token.indexOf('<') + 1, token.indexOf('>'))
      .split(':');

    if (!['int', 'string', 'number'].includes(type)) {
      return false;
    }
    return true;
  };
  SimpleRouter.appendTokenToHash = function (hash, token) {
    return `${hash}/${token}`;
  };
  SimpleRouter.parseParameterRouteToken = function (token) {
    const [parameter, type] = token
      .slice(token.indexOf('<') + 1, token.indexOf('>'))
      .split(':');
    return {
      parameter,
      type,
    };
  };
  // (hash: string, route: string) => false | { [key: string]: number | string }
  SimpleRouter.getMatch = function (hash, route) {
    const hashTokens = SimpleRouter.getTokens(hash);
    const routeTokens = SimpleRouter.getTokens(route);
    const params = {};
    let reconstructedHash = '#!';
    if (hashTokens.length !== routeTokens.length) return false;
    for (let i of Object.keys(hashTokens)) {
      const hashToken = hashTokens[i];
      const routeToken = routeTokens[i];
      if (SimpleRouter.isParameterRouteToken(routeToken)) {
        const { parameter, type } = SimpleRouter.parseParameterRouteToken(
          routeToken
        );
        if (type === 'int') {
          if (!Router.isInt(hashToken)) return false;
          params[parameter] = parseInt(hashToken);
          reconstructedHash = SimpleRouter.appendTokenToHash(
            reconstructedHash,
            hashToken
          );
        } else if (type === 'number' && !Router.isNumber(hasToken)) {
          if (!Router.isNumber(hashToken)) return false;
          params[parameter] = Number(hashToken);
          reconstructedHash = SimpleRouter.appendTokenToHash(
            reconstructedHash,
            hashToken
          );
        } else if (type === 'string') {
          params[parameter] = hashToken;
          reconstructedHash = SimpleRouter.appendTokenToHash(
            reconstructedHash,
            hashToken
          );
        }
      } else {
        if (hashToken !== routeToken) return false;
        reconstructedHash = SimpleRouter.appendTokenToHash(
          reconstructedHash,
          hashToken
        );
      }
    }
    return { params, reconstructedHash };
  };
  SimpleRouter.getRouteAndParamsFromHash = function (hash, routes) {
    for (let route of Object.keys(routes)) {
      const match = SimpleRouter.getMatch(hash, route);
      if (match) {
        const { params, reconstructedHash } = match;
        return { route, params, reconstructedHash };
      }
    }
    return { route: '', params: {}, reconstructedHash: '' };
  };
  /**
   * @param {Object.<string, number | string>} params
   */
  this.setParams = function (params) {
    this.params = params;
    // Todo: Maybe dispatch some kind of event
  };
  this.setCurrentRoute = function (route) {
    this.currentRoute = route;
  };
  this.setCurrentTitle = function (title) {
    this.currentTitle = title;
  };
  SimpleRouter.removeHash = function () {
    return history.replaceState(null, null, ' ');
  };
  this.syncWithHash = function () {
    const { hash } = location;
    const {
      route,
      params,
      reconstructedHash,
    } = SimpleRouter.getRouteAndParamsFromHash(hash, this.routes);
    this.setParams(params);
    this.setCurrentRoute(this.routes[route]);
    this.setCurrentTitle(this.titles[route]);
    if (reconstructedHash === '#!') {
      SimpleRouter.removeHash();
    } else {
      history.replaceState(undefined, undefined, reconstructedHash);
    }
    document.title = this.currentTitle;
  };
  this.params = {};
  this.currentRoute = '';
  this.routes = {};
  this.titles = {};
  this.hashChangeListeners = [];
  this.setRoutes(routes);
  window.addEventListener('hashchange', () => {
    this.syncWithHash();
    this.callHashChangeListeners();
  });
  /**
   * @param {string} route
   * One of the registered routes, without hashbang
   */
  this.navigateTo = (route) => {
    location.hash = `#!${route}`;
  };

  this.refresh = () => this.syncWithHash();

  // @possiblyNumber: string
  SimpleRouter.isNumber = function (possiblyNumber) {
    return !isNaN(Number(possiblyNumber));
  };
  SimpleRouter.isInt = function (possiblyInt) {
    return (
      SimpleRouter.isNumber(possiblyInt) &&
      parseInt(possiblyInt) === Number(possiblyInt)
    );
  };
  this.onHashChange = (callback) => {
    this.hashChangeListeners.push(callback);
    this.callHashChangeListeners();
  };
  this.callHashChangeListeners = function () {
    this.hashChangeListeners.forEach((hashChangeListener) =>
      hashChangeListener({
        params: this.params,
        currentRoute: this.currentRoute,
      })
    );
  };
  this.getParams = () => this.params;
  this.getCurrentTitle = () => this.currentTitle;
  SimpleRouter.isProp = (propsOrChild) =>
    !(propsOrChild instanceof HTMLElement || typeof propsOrChild === 'string');
}

module.exports = SimpleRouter;

  return module.exports;
})();

modules['src/libraries/simpleState/SimpleState.js'] = (() => {
  const module = { exports: {} };
  const simpleState = (initialState) => {
  const state = initialState;
  const stateChangeCallbacks = [];
  const emit = () => {
    stateChangeCallbacks.forEach((stateChangeCallback) => {
      stateChangeCallback({ state, setState });
    });
  };
  const setState = (newState) => {
    Object.assign(state, newState);
    emit();
  };
  const addStateChangeListener = (stateChangeCallback) => {
    const element = { state, setState };
    stateChangeCallbacks.push(stateChangeCallback);
    return element;
  };
  return {
    state,
    setState,
    addStateChangeListener,
  };
};

module.exports = simpleState;

  return module.exports;
})();

modules['src/libraries/observable/Observable.js'] = (() => {
  const module = { exports: {} };
  class Observable {
  constructor(value) {
    // Maybe this can cause an id collision of two observables created almost at the same time
    this._id = `${Math.random()}${+new Date()}`;
    this._value = value;
  }
  emit() {
    window.dispatchEvent(
      new CustomEvent(this._id, {
        detail: this._value,
      })
    );
  }
  get id() {
    return this._id;
  }
  get value() {
    return this._value;
  }
  set value(value) {
    // Maybe this should do a deep compare in case value is an object?
    if (value === this._value) return;
    this._value = value;
    this.emit();
  }
}

module.exports = Observable;

  return module.exports;
})();

modules['src/data/Data.js'] = (() => {
  const module = { exports: {} };
  const getAllProjects = () => {
  const projects = JSON.parse(localStorage.getItem('projects')) || [];
  return projects.map(
    ({ id, name, apiUrl, apiInterval, derivedValuesCode, widgetsCode }) => ({
      id: id || '',
      name: name || '',
      apiUrl: apiUrl || '',
      apiInterval: apiInterval || 0,
      derivedValuesCode: derivedValuesCode || '',
      widgetsCode: widgetsCode || '',
    })
  );
};

const getExportedProject = () => [];

const getProjectById = (projectIdId) =>
  JSON.parse(localStorage.getItem('projects')).find(
    ({ id }) => id == projectId
  );

const createProject = (newProject) => {
  const projects = getAllProjects();
  const projectsUpdated = [
    ...projects,
    {
      ...newProject,
      id: `${Math.random()}${+new Date()}`,
    },
  ];
  localStorage.setItem('projects', JSON.stringify(projectsUpdated));
};

const updateProjectById = (projectId, project) => {
  const projects = getAllProjects();
  const projectIndex = projects.findIndex(({ id }) => id === projectId);
  console.log('projectId: ', projectId);
  console.log('project: ', project);
  if (projectIndex === -1) {
    console.warn('Tried to update nonexistent project');
    return;
  }
  Object.assign(projects[projectIndex], project);
  localStorage.setItem('projects', JSON.stringify(projects));
};

const deleteProjectById = (projectId) => {
  const projects = getAllProjects();
  const updatedProjects = projects.filter(({ id }) => id !== projectId);
  localStorage.setItem('projects', JSON.stringify(updatedProjects));
};

module.exports = {
  getAllProjects,
  getExportedProject,
  getProjectById,
  createProject,
  updateProjectById,
  deleteProjectById,
};

  return module.exports;
})();

modules['src/model/Model.js'] = (() => {
  const module = { exports: {} };
  const Observable = include('src/libraries/observable/Observable.js');
const {
  getExportedProject,
  getAllProjects,
  getProjectById,
  createProject,
  updateProjectById,
  deleteProjectById,
} = include('src/data/Data.js');

const evaluateCode = (apiResponse, widgetsCode) => {
  const evaluatedCode = eval(widgetsCode);
  const evaluatedCodeCalledWithApiResponse = evaluatedCode(
    JSON.parse(apiResponse)
  );
  return evaluatedCodeCalledWithApiResponse;
};

const Model = ({ router, isExported, state, setState }) => {
  const dataModel = { projects: [] };
  const viewModel = {};

  viewModel.loadAllProjects = () => {
    dataModel.projects = state.isExported
      ? getExportedProject()
      : getAllProjects();
    setState({
      projects: dataModel.projects.map(
        ({ id, name, apiRequests, derivedValuesCode, widgetsCode }, index) => ({
          id,
          name,
          nameInputValue: name,
        })
      ),
    });
    if (state.isExported) {
      setState({ selectedProjectId: dataModel.projects[0].id });
    }
    // I am here now
    const selectedProject = dataModel.projects.find(
      ({ id }) => id === state.selectedProjectId
    );
    if (!selectedProject) {
      setState({
        selectedProjectId: null,
        selectedProjectName: null,
        selectedApiUrl: '',
        selectedApiInterval: null,
        selectedWidgetsCode: '',
      });
      return;
    }
    setState({
      selectedProjectName: selectedProject.name,
      selectedApiUrl: selectedProject.apiUrl,
      selectedAPiInterval: selectedProject.apiInterval,
      selectedWidgetsCode: selectedProject.widgetsCode,
    });
  };
  viewModel.loadAllProjects();

  viewModel.createNewProject = () => {
    createProject({
      name: 'Untitled project',
      apiUrl: '',
      apiInterval: 0,
      widgetsCode: '',
    });
    viewModel.loadAllProjects();
  };

  viewModel.setProjectNameInputValue = (projectId, inputValue) => {
    setState({
      projects: state.projects.map((project) => {
        if (project.id === projectId) {
          return { ...project, nameInputValue: inputValue };
        }
        return project;
      }),
    });
  };

  viewModel.editProjectName = (projectId) => {
    setState({
      projects: state.projects.map((project) => {
        if (project.id === projectId) {
          return { ...project, isEditing: true };
        }
        return project;
      }),
    });
  };

  viewModel.cancelEditingProjectName = (projectId) => {
    setState({
      projects: state.projects.map((project) => {
        if (project.id === projectId) {
          return { ...project, nameInputValue: project.name, isEditing: false };
        }
        return project;
      }),
    });
  };

  viewModel.saveProjectName = (projectId) => {
    const project = state.projects.find(({ id$ }) => id$.value === projectId);
    updateProjectById(projectId, {
      name: project.nameInputValue$.value,
    });
    viewModel.loadAllProjects();
  };

  viewModel.saveSelectedProject = () => {
    updateProjectById(viewModel.selectedProjectId$.value, {
      name: viewModel.selectedName$.value,
      apiUrl: viewModel.selectedApiUrl$.value,
      apiInterval: viewModel.selectedApiInterval$.value,
      derivedValuesCode: viewModel.selectedDerivedValuesCode$.value,
      widgetsCode: viewModel.selectedWidgetsCode$.value,
    });
    viewModel.loadAllProjects();
  };

  viewModel.deleteProject = (projectId) => {
    deleteProjectById(projectId);
    viewModel.loadAllProjects();
  };

  viewModel.updateApiUrl = (projectId, apiUrl) => {
    updateProjectById(projectId, { apiUrl });
    viewModel.loadAllProjects();
  };

  viewModel.updateApiInterval = (projectId, apiInterval) => {
    updateProjectById(projectId, { apiInterval });
    viewModel.loadAllProjects();
  };

  viewModel.updateWidgetsCode = (projectId, widgetsCode) => {
    updateProjectById(projectId, { widgetsCode });
    viewModel.loadAllProjects();
    updateValues();
  };

  viewModel.testApiUrlInput = () => {
    fetch(state.selectedApiUrl)
      .then((response) => response.json())
      .then((jsonResponse) => {
        setState({
          selectedApiUrlTestPreview: JSON.stringify(jsonResponse, null, 2),
        });
      });
  };

  const updateValues = () => {
    let evaluatedCode;
    try {
      evaluatedCode = evaluateCode(
        state.apiResponse,
        state.selectedWidgetsCode
      );
    } catch (e) {
      console.log('Failed to evaluate code: ', e);
      evaluatedCode = [];
    }

    setState({
      widgets: evaluatedCode,
    });
  };

  const fetchDataFromApi = () => {
    fetch(state.selectedApiUrl)
      .then((response) => response.json())
      .then((jsonResponse) => {
        setState({
          apiResponse: JSON.stringify(jsonResponse, null, 2),
        });
        updateValues();
      });
  };

  const repeatedlyFetchDataFromApi = (timeoutInSeconds) =>
    setTimeout(() => {
      console.log('repeatedly fetch data from api');
      if (state.selectedApiInterval !== 0) {
        fetchDataFromApi();
      }
      if (timeoutInSeconds === state.selectedApiInterval) {
        repeatedlyFetchDataFromApi(timeoutInSeconds);
      }
    }, timeoutInSeconds * 1000);
  repeatedlyFetchDataFromApi();

  /** TODO
  addEventListener(viewModel.selectedApiInterval$.id, () =>
    setTimeout(() => {
      fetchDataFromApi();
      repeatedlyFetchDataFromApi(viewModel.selectedApiInterval$.value);
    }, 1000)
  );
  addEventListener(viewModel.selectedApiUrl$.id, () =>
    setTimeout(() => {
      fetchDataFromApi();
      repeatedlyFetchDataFromApi(viewModel.selectedApiInterval$.value);
    }, 1000)
  );
  */

  const syncSelectedProjectWithRouter = ({ params, currentRoute }) => {
    setState({ currentRoute, params });
    if (currentRoute.indexOf('/projects/<projectId:string>') === 0) {
      const selectedProject = dataModel.projects.find(
        ({ id }) => id === params.projectId
      );
      setState({
        selectedProjectId: selectedProject.id,
        selectedProjectName: selectedProject.name,
        selectedApiUrl: selectedProject.apiUrl,
        selectedApiInterval: selectedProject.apiInterval,
        selectedWidgetsCode: selectedProject.widgetsCode,
      });
      if (currentRoute === '/projects/<projectId:string>/data-sources') {
        setState({
          lastVisitedProjectView: 'data-sources',
        });
      }
      if (
        currentRoute.indexOf('/projects/<projectId:string>/dashboard/edit') ===
        0
      ) {
        setState({
          lastVisitedProjectView: 'edit-dashboard', // TODO: Check that this works
        });
      }
      if (currentRoute === '/projects/<projectId:string>/dashboard') {
        setState({
          lastVisitedProjectView: 'dashboard',
        });
      }
    }
  };
  syncSelectedProjectWithRouter(router);
  router.onHashChange(syncSelectedProjectWithRouter);

  return viewModel;
};

module.exports = Model;

  return module.exports;
})();

modules['src/libraries/simpleHTML/SimpleHTML.js'] = (() => {
  const module = { exports: {} };
  const doAddInnerShadow = (element) => {
  element.style.boxShadow = 'inset rgba(0, 0, 0, 0.25) 0 0 10px -5px';
};

const doAddShadow = (element) => {
  element.style.boxShadow = 'rgba(0, 0, 0, 0.25) 0 0 10px -5px';
};

const doPatchChildren = (element, newChildren) => {
  newChildren.forEach((newChild, index) => {
    if (element.childNodes[index] === newChild) return;
    while (
      element.childNodes[index] &&
      !newChildren.includes(element.childNodes[index])
    ) {
      element.removeChild(element.childNodes[index]);
    }
    if (element.childNodes[index]) {
      element.insertBefore(newChild, element.childNodes[index]);
      return;
    }
    element.appendChild(newChild);
    return;
  });
  while (newChildren.length < element.childNodes.length) {
    element.removeChild(element.childNodes[newChildren.length]);
  }
};

/**
 * https://stackoverflow.com/questions/27936772/how-to-deep-merge-instead-of-shallow-merge
 *
 * Simple object check.
 * @param item
 * @returns {boolean}
 */
const isObject = (item) => {
  return item && typeof item === 'object' && !Array.isArray(item);
};
/**
 * Deep merge two objects.
 * @param target
 * @param ...sources
 */
const doDeepMerge = (target, ...sources) => {
  if (!sources.length) return target;
  const source = sources.shift();

  if (isObject(target) && isObject(source)) {
    for (const key in source) {
      if (isObject(source[key])) {
        if (!target[key]) Object.assign(target, { [key]: {} });
        doDeepMerge(target[key], source[key]);
      } else {
        Object.assign(target, { [key]: source[key] });
      }
    }
  }

  return doDeepMerge(target, ...sources);
};

const determineIsNullish = (value) => value === null || value === undefined;

/**
 * A component is a function which returns an element and and update method
 * @param {*} elementType
 * @param {*} props
 * @param {*} children
 */
const compose = (elementType, getProps, children) => {
  if (typeof elementType === 'string') {
    element = document.createElement(elementType);
    doDeepMerge(element, getProps());
    children.filter(Boolean).forEach((child) => {
      if (typeof child === 'string') {
        element.appendChild(document.createTextNode(child));
      } else {
        element.appendChild(child);
      }
    });
    element.update = () => {
      doDeepMerge(element, getProps());
      Array.from(element.childNodes).forEach((childNode) => {
        if (typeof childNode.update === 'function') {
          childNode.update;
        }
      });
    };
    return element;
  }
  if (typeof elementType === 'function') {
    console.log('elementType: ', elementType);
    return elementType(props, children);
  }
  throw Error('elementType needs to be either a string or a function');
};

const nullishCoalesce = (primaryValue, backupValue) =>
  determineIsNullish(primaryValue) ? secondaryValue : primaryValue;

class SimpleHTML {
  static isProp = (propsOrChild) =>
    !(propsOrChild instanceof HTMLElement || typeof propsOrChild === 'string');
  static makeElement(elementType, propsOrChild, ...maybeAllChildren) {
    const element = document.createElement(elementType);
    const hasProps = SimpleHTML.isProp(propsOrChild);
    const props = hasProps ? propsOrChild || {} : {};
    const children = hasProps
      ? maybeAllChildren
      : [propsOrChild, ...maybeAllChildren];
    Object.entries(props).forEach(([attribute, value]) => {
      if (attribute === 'style') {
        Object.assign(element.style, value);
      } else if (attribute === 'onClick') {
        element.onclick = value;
      } else if (attribute === 'onInput') {
        element.oninput = value;
      } else {
        element[attribute] = value;
      }
    });
    children
      .filter(Boolean)
      .map((child) =>
        typeof child === 'string' ? document.createTextNode(child) : child
      )
      .forEach((child) => {
        element.appendChild(child);
      });
    return element;
  }
}

const doMerge = (oldElement, newElement) => {
  if (!oldElement.parentNode) return;

  const oldChildren = Array.from(oldElement.childNodes);
  const newChildren = Array.from(newElement.childNodes);
  newChildren.forEach((newChild, i) => {
    let foundMatchingOldChild = false;
    while (oldChildren.length && !foundMatchingOldChild) {
      oldChild = oldChildren.shift();
      if (
        oldChild.component === newChild.component &&
        oldChild instanceof Element
      ) {
        const selectionStart = oldChild.selectionStart;
        const selectionEnd = oldChild.selectionEnd;
        oldChild.value = newChild.value;
        oldChild.selectionStart = selectionStart;
        oldChild.selectionEnd = selectionEnd;

        console.log('oldChild.update: ', oldChild.update);
        console.log('newChild.propsAndChildren: ', newChild.propsAndChildren);
        oldChild.update(...newChild.propsAndChildren);
        if (Object.keys(newChild.propsAndChildren[0]).includes('style')) {
          if (!oldChild.style) {
            Object.keys(oldChild.parentNode.style).forEach((property) => {
              if (!newChild.propsAndChildren[0].style[property]) {
                oldChild.parentNode.style[property] = null;
              }
            });
            Object.assign(
              oldChild.parentNode.style,
              newChild.propsAndChildren[0].style
            );
          } else {
            Object.keys(oldChild.parentNode.style).forEach((property) => {
              if (!newChild.propsAndChildren[0].style[property]) {
                oldChild.style[property] = null;
              }
            });
            Object.assign(oldChild.style, newChild.propsAndChildren[0].style);
          }
        }
        oldChild.innerText = newChild.innerText;

        foundMatchingOldChild = true;
      } else if (
        !(oldChild instanceof Element) &&
        !(newChild instanceof Element)
      ) {
        if (oldChild.data === newChild.data) {
          foundMatchingOldChild = true;
        } else {
          oldChild.data = newChild.data;
        }
        foundMatchingOldChild = true;
      } else {
        oldElement.removeChild(oldChild);
      }
    }
    if (!foundMatchingOldChild) {
      while (oldElement.childNodes[i]) {
        oldElement.removeChild(oldElement.childNodes[i]);
      }
      oldElement.appendChild(newChild);
    }
  });
  while (newChildren.length < oldElement.childNodes.length) {
    oldElement.removeChild(oldElement.childNodes[newChildren.length]);
  }
};

const defineComponent = (elementFunction) => {
  const component = (...propsAndChildren) => {
    const element = elementFunction(...propsAndChildren);
    element.component = component;
    element.propsAndChildren = propsAndChildren;
    element.update = (...newPropsAndChildren) => {
      element.propsAndChildren = newPropsAndChildren;
      doMerge(element, component(...newPropsAndChildren));
    };
    return element;
  };
  return component;
};

const div = defineComponent((props, ...children) =>
  SimpleHTML.makeElement('div', props, ...children)
);

const span = defineComponent((props, ...children) =>
  SimpleHTML.makeElement('span', props, ...children)
);

const a = defineComponent((props, ...children) =>
  SimpleHTML.makeElement('a', props, ...children)
);

const p = defineComponent((props, ...children) =>
  SimpleHTML.makeElement('p', props, ...children)
);

const h1 = defineComponent((props, ...children) =>
  SimpleHTML.makeElement('h1', props, ...children)
);

const h2 = defineComponent((props, ...children) =>
  SimpleHTML.makeElement('h2', props, ...children)
);

const img = defineComponent((props, ...children) =>
  SimpleHTML.makeElement('img', props, ...children)
);

const form = defineComponent((props, ...children) =>
  SimpleHTML.makeElement('form', props, ...children)
);

const input = defineComponent((props) =>
  SimpleHTML.makeElement('input', props)
);

const textarea = defineComponent((props) =>
  SimpleHTML.makeElement('textarea', props)
);

const br = defineComponent((props, ...children) =>
  SimpleHTML.makeElement('br', props, ...children)
);

const button = defineComponent((props, ...children) =>
  SimpleHTML.makeElement('button', props, ...children)
);
// And so on, fill in more as needed...

module.exports = {
  doMerge,
  compose,
  defineComponent,
  div,
  span,
  a,
  p,
  h1,
  h2,
  img,
  form,
  input,
  textarea,
  br,
  button,
  doAddInnerShadow,
  doAddShadow,
  doPatchChildren,
};

  return module.exports;
})();

modules['src/views/project/projectContainer/ProjectContainer.js'] = (() => {
  const module = { exports: {} };
  const { compose } = include('src/libraries/simpleHTML/SimpleHTML.js');

const ProjectContainer = (props, children) => {
  return compose(
    'div',
    () => ({
      style: {
        height: 'calc(100% - 64px)',
        position: 'absolute',
        left: '0',
        right: '0',
      },
    }),
    children
  );
};

module.exports = ProjectContainer;

  return module.exports;
})();

modules['src/components/horizontalNavigator/HorizontalNavigator.js'] = (() => {
  const module = { exports: {} };
  const { compose } = include('src/libraries/simpleHTML/SimpleHTML.js');

const HorizontalNavigator = ({}, children) => {
  return compose(
    'div',
    () => ({
      style: {
        height: '64px',
        boxShadow: 'rgba(0, 0, 0, 0.25) 0 0 10px -5px',
        background: 'white',
        color: 'darkslategray',
      },
    }),
    children
  );
};

module.exports = HorizontalNavigator;

  return module.exports;
})();

modules['src/app/titleBar/atoms.js'] = (() => {
  const module = { exports: {} };
  const { compose } = include('src/libraries/simpleHTML/SimpleHTML.js');

const ViewTitle = (_, children) => {
  return compose(
    'div',
    () => ({
      style: { fontSize: '32px', padding: '16px', display: 'inline-block' },
    }),
    children
  );
};

const ExportButton = (getProps, children) => {
  return compose(
    'div',
    () => ({
      onclick: getProps().onclick,
      style: {
        fontSize: '16px',
        padding: '0 16px',
        float: 'right',
        lineHeight: '64px',
        cursor: 'pointer',
      },
    }),
    children
  );
};

module.exports = { ViewTitle, ExportButton };

  return module.exports;
})();

modules['src/app/titleBar/TitleBar.js'] = (() => {
  const module = { exports: {} };
  const HorizontalNavigator = include(
  'src/components/horizontalNavigator/HorizontalNavigator.js'
);
const { ViewTitle, ExportButton } = include('src/app/titleBar/atoms.js');

const { compose } = include('src/libraries/simpleHTML/SimpleHTML.js');

const TitleBar = (getProps) => {
  const { viewModel, state } = getProps();
  const { isExported, currentRoute } = state;
  return HorizontalNavigator(() => ({}), [
    ViewTitle(() => ({}), [
      !isExported
        ? compose(
            'span',
            () => ({
              onclick: () => (location.hash = '#!/projects'),
              style: { cursor: 'pointer' },
            }),
            ['Projects']
          )
        : null,
      compose(
        'span',
        () => ({
          style: {
            color: isExported
              ? 'darkslategray'
              : currentRoute.indexOf('/projects/<projectId:string>') === 0
              ? 'darkslategray'
              : 'lightgray',
            cursor: 'pointer',
          },
          onclick: () => {
            if (isExported) {
              location.hash = '#!/';
              return;
            }
            location.hash = `#!/projects/${state.selectedProjectId}/${
              viewModel.lastVisitedProjectView || ''
            }`;
          },
        }),
        [
          state.selectedProjectName
            ? isExported
              ? state.selectedProjectName
              : ` / ${state.selectedProjectName}`
            : '',
        ]
      ),
    ]),
    !isExported
      ? ExportButton(
          () => ({
            onclick: () => {
              const { state } = getProps();
              const element = document.createElement('a');
              // SInce just the first occurrence of the code will be replaced, we need to make sure that this code does not replace itself, so we construct the match on call time
              const fileContent = document.head.innerHTML
                .replace(
                  '*c*o*n*s*t* *i*s*E*x*p*o*r*t*e*d* *=* *f*a*l*s*e*;*'
                    .split('*')
                    .join(''),
                  '*c*o*n*s*t* *i*s*E*x*p*o*r*t*e*d* *=* *t*r*u*e*;*'
                    .split('*')
                    .join('')
                )
                .replace(
                  '*c*o*n*s*t* *g*e*t*E*x*p*o*r*t*e*d*P*r*o*j*e*c*t* *=* *(*)* *=*>* *[*]*;*'
                    .split('*')
                    .join(''),
                  `*c*o*n*s*t* *g*e*t*E*x*p*o*r*t*e*d*P*r*o*j*e*c*t* *=* *(*)* *=*>*`
                    .split('*')
                    .join('') +
                    JSON.stringify([
                      {
                        id: state.selectedProjectId,
                        name: state.selectedProjectName,
                        apiUrl: state.selectedApiUrl,
                        apiInterval: state.selectedApiInterval,
                        derivedValuesCode: state.selectedDerivedValuesCode,
                        widgetsCode: state.selectedWidgetsCode,
                      },
                    ])
                );
              const file = new Blob([fileContent], { type: 'text/plain' });
              element.href = URL.createObjectURL(file);
              element.download = `${state.selectedProjectName
                .toLowerCase()
                .split(' ')
                .join('-')}.html`;
              document.body.appendChild(element); // Required for this to work in FireFox
              element.click();
            },
          }),
          ['Export']
        )
      : null,
  ]);
};

module.exports = TitleBar;

  return module.exports;
})();

modules['src/views/projects/newProject/NewProject.js'] = (() => {
  const module = { exports: {} };
  const { compose } = include('src/libraries/simpleHTML/SimpleHTML.js');

// getProps::() => { viewModel }
const NewProject = (getProps) => {
  let color = 'slategray';
  const element = compose(
    'span',
    () => ({
      onmouseenter: () => {
        color = 'darkslategray';
        element.update();
      },
      onmouseleave: () => {
        color = 'slategray';
        element.update();
      },
      onclick: getProps().viewModel.createNewProject,
      style: {
        color,
        margin: '32px',
        padding: '0 16px',
        height: '64px',
        background: 'none',
        lineHeight: '64px',
        fontSize: '16px',
        display: 'inline-block',
      },
    }),
    ['New project']
  );
  return element;
};

module.exports = NewProject;

  return module.exports;
})();

modules['src/views/projects/projectPreviewContainer/ProjectPreviewContainer.js'] = (() => {
  const module = { exports: {} };
  const { compose } = include('src/libraries/simpleHTML/SimpleHTML.js');

const ProjectPreviewContainer = (_, children) => {
  return compose(
    'div',
    () => ({
      style: {
        color: 'dimgray',
        margin: '32px 32px 0 32px',
        height: '64px',
        background: 'white',
        lineHeight: '64px',
        fontSize: '16px',
      },
    }),
    children
  );
};

module.exports = ProjectPreviewContainer;

  return module.exports;
})();

modules['src/views/projects/projectPreviewButton/ProjectPreviewButton.js'] = (() => {
  const module = { exports: {} };
  const { compose } = include('src/libraries/simpleHTML/SimpleHTML.js');

// getProps::() => value
const ProjectPreviewButton = (getProps) => {
  let isHovered = false;
  const element = compose(
    'button',
    () => ({
      onmouseenter: () => {
        isHovered = true;
        element.update();
      },
      onmouseleave: () => {
        isHovered = false;
        element.update();
      },
      style: {
        color: isHovered ? 'darkslategray' : 'slategray',
        height: '64px',
        background: 'white',
        lineHeight: '64px',
        fontSize: '16px',
        width: '64px',
        textAlign: 'center',
        border: 'none',
        outline: 'none',
        cursor: 'pointer',
      },
    }),
    [getProps().value]
  );
  return element;
};

module.exports = ProjectPreviewButton;

  return module.exports;
})();

modules['src/views/projects/projectPreview/ProjectPreview.js'] = (() => {
  const module = { exports: {} };
  const ProjectPreviewContainer = include(
  'src/views/projects/projectPreviewContainer/ProjectPreviewContainer.js'
);
const ProjectPreviewButton = include(
  'src/views/projects/projectPreviewButton/ProjectPreviewButton.js'
);
const { compose } = include('src/libraries/simpleHTML/SimpleHTML.js');

// getProps::() => { state, viewModel, name, id }
const ProjectPreview = (getProps) => {
  return ProjectPreviewContainer(() => ({}), [
    compose(
      'div',
      () => {
        const { id, state } = getProps();
        return {
          onclick: () => {
            location.hash = `#!/projects/${id}/${
              state.lastVisitedProjectView || ''
            }`;
          },
          style: {
            padding: '0 16px',
            width: 'calc(100% - 128px)',
            boxSizing: 'border-box',
            display: 'inline-block',
          },
        };
      },
      [getProps().name]
    ),
    ProjectPreviewButton(
      () => ({ onclick: () => viewModel.deleteProject(getProps().id) }),
      ['Delete']
    ),
    ProjectPreviewButton(
      () => ({ onclick: () => viewModel.editProjectName(id$.value) }),
      ['Edit']
    ),
  ]);
};

module.exports = ProjectPreview;

  return module.exports;
})();

modules['src/views/dataSources/apiInputLabel/ApiInputLabel.js'] = (() => {
  const module = { exports: {} };
  const { compose } = include('src/libraries/simpleHTML/SimpleHTML.js');

const ApiInputLabel = ({ label }) => {
  return compose(
    'span',
    () => ({
      // TODO: Make this one align nicely next to the input
      color: 'dimgray',
      height: '64px',
      padding: '0 16px',
      lineHeight: '64px',
      fontSize: '16px',
      width: '192px',
      border: 'none',
      outline: 'none',
      display: 'inline-block',
      boxSizing: 'border-box',
    }),
    [label]
  );
};

module.exports = ApiInputLabel;

  return module.exports;
})();

modules['src/views/dataSources/apiInputContainer/ApiInputContainer.js'] = (() => {
  const module = { exports: {} };
  const { compose } = include('src/libraries/simpleHTML/SimpleHTML.js');

const ApiInputContainer = (_, children) => {
  return compose(
    'span',
    () => ({
      style: {
        // TODO: Make this one align nicely next to the input
        color: 'dimgray',
        height: '64px',
        padding: '8px',
        lineHeight: '64px',
        fontSize: '16px',
        width: 'calc(100% - 192px)',
        display: 'inline-block',
        boxSizing: 'border-box',
      },
    }),
    children
  );
};

module.exports = ApiInputContainer;

  return module.exports;
})();

modules['src/components/fullWidthCard/FullWidthCard.js'] = (() => {
  const module = { exports: {} };
  const { compose } = include('src/libraries/simpleHTML/SimpleHTML.js');

const FullWidthCard = (_, children) => {
  return compose(
    'div',
    () => ({
      style: {
        color: 'dimgray',
        margin: '32px 32px 0 32px',
        background: 'white',
        lineHeight: '64px',
        fontSize: '16px',
      },
    }),
    children
  );
};

module.exports = FullWidthCard;

  return module.exports;
})();

modules['src/views/dataSources/apiUrlTestPreview/ApiUrlTestPreview.js'] = (() => {
  const module = { exports: {} };
  const { compose } = include('src/libraries/simpleHTML/SimpleHTML.js');

const ApiUrlTestPreview = (_, children) => {
  return compose(
    'div',
    () => ({
      style: {
        color: 'lightslategray',
        background: 'ghostwhite',
        lineHeight: '32px',
        fontSize: '0 16px',
        width: '100%',
        margin: '8px',
        padding: '8px',
        display: 'inline-block',
        boxSizing: 'border-box',
        fontFamily: '"Courier New", Courier, monospace',
        whiteSpace: 'pre-wrap',
        maxHeight: '448px',
        minHeight: '48px',
        overflow: 'auto',
      },
    }),
    children
  );
};

module.exports = ApiUrlTestPreview;

  return module.exports;
})();

modules['src/libraries/simpleUI/Constants.js'] = (() => {
  const module = { exports: {} };
  const Colors = {
  TextColor: 'slategray',
  HighlightedTextColor: 'darkslategray',
  DisabledTextColor: 'lightgray',
  HighlightColor: 'deepskyblue',
};

const Sizes = {
  FontSize: 15,
  Padding: 10,
  Unit: 20,
};

module.exports = {
  Colors,
  Sizes,
};

  return module.exports;
})();

modules['src/libraries/simpleUI/NavigationButton.js'] = (() => {
  const module = { exports: {} };
  const { Colors } = include('src/libraries/simpleUI/Constants.js');
const { compose } = include('src/libraries/simpleHTML/SimpleHTML.js');

const getColor = (isHovered, isSelected) => {
  return isSelected || isHovered
    ? Colors.HighlightedTextColor
    : Colors.TextColor;
};

const getBorderBottom = (isSelected) => {
  return isSelected ? `2px solid ${Colors.HighlightColor}` : 'none';
};

const NavigationButton = (getProps) => {
  let isHovered = false;
  const { label, href, isSelected } = getProps();
  const props = { label, href, isSelected };
  const element = compose(
    'span',
    () => {
      const { isSelected } = getProps();
      return {
        style: {
          display: 'inline-block',
          textAlign: 'center',
          boxSizing: 'border-box',
          width: '160px',
          height: '40px',
          lineHeight: '40px',
          fontSize: '30px',
          borderBottom: getBorderBottom(isSelected),
          color: getColor(isHovered, isSelected),
        },
      };
    },
    [
      compose(
        'a',
        () => ({
          style: {
            textDecoration: 'none',
            display: 'inline-block',
            width: '100%',
          },
          href: getProps().href,
          onmouseenter: () => {
            isHovered = true;
            element.update();
          },
          onMouseLeave: () => {
            isHovered = false;
            element.update();
          },
        }),
        [props.label]
      ),
    ]
  );
  return element;
};

module.exports = NavigationButton;

  return module.exports;
})();

modules['src/views/project/projectNavigator/dataSourcesButton/DataSourcesButton.js'] = (() => {
  const module = { exports: {} };
  const NavigationButton = include('src/libraries/simpleUI/NavigationButton.js');

// getProps::() => { state }
const DataSourcesButton = (getProps) => {
  const determineIsSelected = (currentRoute) =>
    [
      '/projects/<projectId:string>',
      '/projects/<projectId:string>/data-sources',
    ].includes(currentRoute);

  const getHref = (selectedProjectId) =>
    `#!/projects/${selectedProjectId}/data-sources`;

  const element = NavigationButton(() => {
    const { currentRoute, selectedProjectId } = getProps().state;
    return {
      label: 'Data sources',
      isSelected: determineIsSelected(currentRoute),
      href: getHref(selectedProjectId),
    };
  });

  const updateNavigationButton = element.update;

  element.update = () => {
    updateNavigationButton();
  };

  return element;
};

module.exports = DataSourcesButton;

  return module.exports;
})();

modules['src/views/project/projectNavigator/dashboardEditorButton/DashboardEditorButton.js'] = (() => {
  const module = { exports: {} };
  const NavigationButton = include('src/libraries/simpleUI/NavigationButton.js');

const DashboardEditorButton = (getProps) => {
  const determineIsSelected = (currentRoute) =>
    currentRoute === '/projects/<projectId:string>/dashboard/edit';

  const getHref = (selectedProjectId) =>
    `#!/projects/${selectedProjectId}/dashboard/edit`;

  const element = NavigationButton(() => {
    const { currentRoute, selectedProjectId } = getProps().state;
    return {
      label: 'Dashboard editor',
      isSelected: determineIsSelected(currentRoute),
      href: getHref(selectedProjectId),
    };
  });

  const updateNavigationButton = element.update;

  element.update = () => {
    updateNavigationButton();
  };

  return element;
};

module.exports = DashboardEditorButton;

  return module.exports;
})();

modules['src/views/project/projectNavigator/dashboardButton/DashboardButton.js'] = (() => {
  const module = { exports: {} };
  const NavigationButton = include('src/libraries/simpleUI/NavigationButton.js');

const DashboardButton = (getProps) => {
  const determineIsSelected = (currentRoute) =>
    currentRoute === '/projects/<projectId:string>/dashboard';

  const getHref = (selectedProjectId) =>
    `#!/projects/${selectedProjectId}/dashboard`;

  const element = NavigationButton(() => {
    const { currentRoute, selectedProjectId } = getProps().state;
    return {
      label: 'Dashboard',
      isSelected: determineIsSelected(currentRoute),
      href: getHref(selectedProjectId),
    };
  });

  const updateNavigationButton = element.update;

  element.update = () => {
    updateNavigationButton();
  };

  return element;
};

module.exports = DashboardButton;

  return module.exports;
})();

modules['src/views/project/projectNavigator/ProjectNavigator.js'] = (() => {
  const module = { exports: {} };
  const DataSourcesButton = include(
  'src/views/project/projectNavigator/dataSourcesButton/DataSourcesButton.js'
);
const DashboardEditorButton = include(
  'src/views/project/projectNavigator/dashboardEditorButton/DashboardEditorButton.js'
);
const DashboardButton = include(
  'src/views/project/projectNavigator/dashboardButton/DashboardButton.js'
);
const { compose } = include('src/libraries/simpleHTML/SimpleHTML.js');

const Navigator = ({}, children) => {
  element = compose('div', () => ({ style: { height: '40px' } }), children);
  element.update = ({}) => {};
  return element;
};

const ProjectNavigator = (getProps) => {
  const element = Navigator({}, [
    DataSourcesButton(getProps),
    DashboardEditorButton(getProps),
    DashboardButton(getProps),
  ]);
  console.log('projectNavigator: ', element);
  return element;
};

module.exports = ProjectNavigator;

  return module.exports;
})();

modules['src/libraries/styled/styled.js'] = (() => {
  const module = { exports: {} };
  const styled = style => Component => (...children) =>
  Component(...children).setStyle(style);

module.exports = styled;

  return module.exports;
})();

modules['src/libraries/observableHtml/ObservableHtml.js'] = (() => {
  const module = { exports: {} };
  const Observable = include('src/libraries/observable/Observable.js');

const observableToNode$ = (observable$) => {
  if (
    // If it is observable value
    observable$ instanceof Observable
  ) {
    if (['string', 'number'].includes(typeof observable$.value)) {
      const textElement = document.createElement('span');
      const textNode = document.createTextNode(observable$.value);
      textElement.appendChild(textNode);
      textElement.classList.add(observable$.id);
      window.addEventListener(observable$.id, ({ detail }) => {
        textElement.innerHTML = '';
        textElement.appendChild(document.createTextNode(detail));
      });
      return textElement;
    }
    if (Array.isArray(observable$.value)) {
      const elements = observable$.value.map(observableToNode$).flat();
      elements.forEach((element, index) => {
        element.classList.add(`${observable$.id}${index}`);
        window.addEventListener(observable$.id, ({ detail }) => {
          // Remove all the existing elements except the first
          let insertionPositions = [];
          for (let index = 0; index < 100; index++) {
            Array.from(
              document.getElementsByClassName(`${observable$.id}${index}`)
            ).forEach((elementToReplace, i) => {
              const insertionParent = elementToReplace.parentNode;
              const insertionIndex = Array.from(
                elementToReplace.parentNode.children
              ).indexOf(elementToReplace);
              insertionPositions.push({
                parent: insertionParent,
                insertionIndex: insertionIndex,
              });
              elementToReplace.parentNode.removeChild(elementToReplace);
            });
          }

          // For each of the first existing elements
          insertionPositions.forEach(({ parent, insertionIndex }, index) => {
            // Create a fragment and add all the elements inside it
            const fragment = document.createDocumentFragment();
            observable$.value.forEach((arrayElement, index) => {
              // I might need to have another level of loop here in case observableToNode$ returns more than one node
              const node = observableToNode$(arrayElement);
              node.classList.add(`${observable$.id}${index}`);
              fragment.appendChild(node);
            });
            // Repalact the first elemet with the fragments containing the new elements
            parent.insertBefore(fragment, parent.children[insertionIndex]);
          });
        });
      });
      return elements;
    }
  }
  if (
    // If it is non-observable value
    ['string', 'number'].includes(typeof observable$)
  ) {
    const textNode = document.createTextNode(observable$);
    return textNode;
  }
  // If it is a dom node
  return observable$;
};

const createElement$ = (elementType, ...observables) => {
  const element = document.createElement(elementType);
  const nodes = observables.map(observableToNode$).flat();
  nodes.forEach((node) => element.appendChild(node));

  // Note that styleObject$ is an object with observable values, not an observable object
  element.setStyle = (styleObject$) => {
    Object.entries(styleObject$).forEach(([styleProperty, styleValue$]) => {
      if (styleValue$ instanceof Observable) {
        element.style[styleProperty] = styleValue$.value;
        window.addEventListener(styleValue$.id, ({ detail }) => {
          element.style[styleProperty] = detail;
        });
        return;
      }
      element.style[styleProperty] = styleValue$;
    });
    return element;
  };
  element.setProps = (propsObject) => {
    Object.entries(propsObject).forEach(([propKey, propValue$]) => {
      if (propValue$ instanceof Observable) {
        element[propKey] = propValue$.value;
        window.addEventListener(propValue$.id, ({ detail }) => {
          element[propKey] = detail;
        });
        return;
      }
      element[propKey] = propValue$;
    });
    return element;
  };
  element.onClick = (clickCallback) => {
    element.style.cursor = 'pointer';
    element.onclick = () => clickCallback(element);
    return element;
  };
  element.onMouseEnter = (mouseEnterCallback) => {
    element.onmouseenter = () => mouseEnterCallback(element);
    return element;
  };
  element.onMouseLeave = (mouseLeaveCallback) => {
    element.onmouseleave = () => mouseLeaveCallback(element);
    return element;
  };
  element.onInput = (inputCallback) => {
    element.oninput = () => inputCallback(element);
    return element;
  };
  element.onChange = (changeCallback) => {
    element.onchange = () => changeCallback(element);
    return element;
  };
  return element;
};
const a$ = (...children) => createElement$('a', ...children);
const div$ = (...children) => createElement$('div', ...children);
const span$ = (...children) => createElement$('span', ...children);
const h1$ = (...children) => createElement$('h1', ...children);
const textArea$ = (value = '') =>
  createElement$('textarea').setProps({ value });
const br$ = () => createElement('br');
const select$ = (...children) => createElement$('select', ...children);
const button$ = (...children) => createElement$('button', ...children);
const option$ = ({ value, label }) =>
  createElement$('option', label).setProps({ value });
const input$ = (value = '') => createElement$('input').setProps({ value });
const canvas$ = ({ width$, height$ }) =>
  createElement$('canvas').setProps({
    width: width$,
    height: height$,
  });

module.exports = {
  createElement$,
  a$,
  div$,
  span$,
  h1$,
  textArea$,
  br$,
  select$,
  button$,
  option$,
  input$,
  canvas$,
};

  return module.exports;
})();

modules['src/views/projects/projectNameInputContainer/ProjectNameInputContainer.js'] = (() => {
  const module = { exports: {} };
  const styled = include('src/libraries/styled/styled.js');
const { span$ } = include('src/libraries/observableHtml/ObservableHtml.js');

const ProjectNameInputContainer$ = styled({
  // TODO: Make this one align nicely next to the input
  color: 'dimgray',
  height: '64px',
  padding: '8px',
  lineHeight: '64px',
  fontSize: '16px',
  width: 'calc(100% - 128px)',
  display: 'inline-block',
  boxSizing: 'border-box',
})(span$);

module.exports = ProjectNameInputContainer$;

  return module.exports;
})();

modules['src/views/projects/projectNameInput/ProjectNameInput.js'] = (() => {
  const module = { exports: {} };
  const ProjectPreviewButton = include(
  'src/views/projects/projectPreviewButton/ProjectPreviewButton.js'
);
const ProjectPreviewContainer = include(
  'src/views/projects/projectPreviewContainer/ProjectPreviewContainer.js'
);
const ProjectNameInputContainer = include(
  'src/views/projects/projectNameInputContainer/ProjectNameInputContainer.js'
);

// getProps::() => { viewModel, id, nameInputValue }
const ProjectNameInput = ({ viewModel, id$, nameInputValue$ }) => {
  return ProjectPreviewContainer(() => ({}), [
    ProjectNameInputContainer(
      () => ({
        oninput: ({ value }) => {
          const { id, viewModel } = getProps();
          viewModel.setProjectNameInputValue(id, value);
        },
      }),
      [getProps().nameInputValue]
    ),
    ProjectPreviewButton(
      () => ({
        onclick: () => {
          const { id, viewModel } = getProps();
          viewModel.cancelEditingProjectName(id);
        },
      }),
      ['Cancel']
    ),
    ProjectPreviewButton(
      () => ({
        onclick: () => {
          const { id, viewModel } = getProps();
          viewModel.saveProjectName(id);
        },
      }),
      ['Save']
    ),
  ]);
};

module.exports = ProjectNameInput;

  return module.exports;
})();

modules['src/views/projects/Projects.js'] = (() => {
  const module = { exports: {} };
  const ProjectPreview = include(
  'src/views/projects/projectPreview/ProjectPreview.js'
);
const ProjectNameInput = include(
  'src/views/projects/projectNameInput/ProjectNameInput.js'
);
const NewProject = include('src/views/projects/newProject/NewProject.js');
const { compose } = include('src/libraries/simpleHTML/SimpleHTML.js');

// getProps::() => { viewModel, state }
const Projects = (getProps) => {
  return compose(
    'div',
    () => ({}),
    getProps()
      .state.projects.filter(({ isEmpty }) => !isEmpty)
      .map(({ id, name, nameInputValue, isEditing, isEmpty }) =>
        isEditing
          ? ProjectNameInput(() => ({
              viewModel: getProps().viewModel,
              id,
              nameInputValue,
            }))
          : ProjectPreview(() => ({
              state: getProps().state,
              viewModel: getProps().viewModel,
              id,
              name,
            }))
      ),
    NewProject(getProps)
  );
};

module.exports = Projects;

  return module.exports;
})();

modules['src/components/input/Input.js'] = (() => {
  const module = { exports: {} };
  const styled = include('src/libraries/styled/styled.js');
const { input$ } = include('src/libraries/observableHtml/ObservableHtml.js');

const Input$ = styled({
  color: 'darkslategray',
  background: 'ghostwhite',
  height: '100%',
  padding: '0 8px',
  lineHeight: '64px',
  fontSize: '16px',
  width: '100%',
  border: 'none',
})(input$);

module.exports = Input$;

  return module.exports;
})();

modules['src/views/dataSources/apiIntervalInput/ApiIntervalInput.js'] = (() => {
  const module = { exports: {} };
  const ProjectPreviewContainer = include(
  'src/views/projects/projectPreviewContainer/ProjectPreviewContainer.js'
);
const ApiInputLabel = include(
  'src/views/dataSources/apiInputLabel/ApiInputLabel.js'
);
const Input$ = include('src/components/input/Input.js');
const ApiInputContainer = include(
  'src/views/dataSources/apiInputContainer/ApiInputContainer.js'
);
const { compose, doPatchChildren } = include(
  'src/libraries/simpleHTML/SimpleHTML.js'
);

// getProps::() => { state, viewModel }
const ApiIntervalInput = (getProps) => {
  return ProjectPreviewContainer(() => ({}), [
    ApiInputLabel(() => ({ label: 'Fetch interval (s)' })),
    ApiInputContainer(
      () => ({
        type: 'number',
        min: '0',
        oninput: ({ value }) => {
          viewModel.updateApiInterval(state.selectedProjectId, value);
        },
      }),
      [getProps().state.selectedApiInterval]
    ),
  ]);
};

module.exports = ApiIntervalInput;

  return module.exports;
})();

modules['src/libraries/observable/utils.js'] = (() => {
  const module = { exports: {} };
  const Observable = include('src/libraries/observable/Observable.js');

const valueOf$ = (observable$) =>
  observable$ instanceof Observable ? observable$.value : observable$;

const isObservable$ = (observable$) => observable$ instanceof Observable;

// Currently needs at least two arguments
const add$ = (...observables) => {
  const sum = observables
    .map((observable) =>
      observable instanceof Observable ? observable.value : observable
    )
    .reduce((a, b) => a + b);
  const sum$ = new Observable(sum);
  observables
    .filter((observable) => observable instanceof Observable)
    .forEach((observable) => {
      window.addEventListener(observable.id, ({ detail }) => {
        const sum = observables
          .map((observable) =>
            observable instanceof Observable ? observable.value : observable
          )
          .reduce((a, b) => a + b);
        sum$.value = sum;
      });
    });
  return sum$;
};

// Currently needs at least two arguments
const subtract$ = (...observables) => {
  const difference = observables
    .map((observable) =>
      observable instanceof Observable ? observable.value : observable
    )
    .reduce((a, b) => a - b);
  const difference$ = new Observable(difference);
  observables.forEach((observable) => {
    window.addEventListener(observable.id, ({ detail }) => {
      const difference = observables
        .map((observable) =>
          observable instanceof Observable ? observable.value : observable
        )
        .reduce((a, b) => a - b);
      difference$.value = difference;
    });
  });
  return difference$;
};

// Currently needs at least two arguments
const multiply$ = (...observables) => {
  const product = observables
    .map((observable) =>
      observable instanceof Observable ? observable.value : observable
    )
    .reduce((a, b) => a * b);
  const product$ = new Observable(product);
  observables.forEach((observable) => {
    window.addEventListener(observable.id, ({ detail }) => {
      const product = observables
        .map((observable) =>
          observable instanceof Observable ? observable.value : observable
        )
        .reduce((a, b) => a * b);
      product$.value = product;
    });
  });
  return product$;
};

// Currently needs at least two arguments
const divide$ = (...observables) => {
  const quotient = observables
    .map((observable) =>
      observable instanceof Observable ? observable.value : observable
    )
    .reduce((a, b) => a / b);
  const quotient$ = new Observable(quotient);
  observables.forEach((observable) => {
    window.addEventListener(observable.id, ({ detail }) => {
      const quotient = observables
        .map((observable) =>
          observable instanceof Observable ? observable.value : observable
        )
        .reduce((a, b) => a / b);
      quotient$.value = quotient;
    });
  });
  return quotient$;
};

const choose$ = (observable, option1, option2) => {
  const result$ = new Observable(
    (observable instanceof Observable ? observable.value : observable)
      ? option1 instanceof Observable
        ? option1.value
        : option1
      : option2 instanceof Observable
      ? option2.value
      : option2
  );
  [observable, option1, option2]
    .filter((observable) => observable instanceof Observable)
    .forEach((observable) => {
      window.addEventListener(observable.id, ({ detail }) => {
        // TODO: Make it possible to set a specific child of an observable
        result$.value = (
          observable instanceof Observable ? observable.value : observable
        )
          ? option1 instanceof Observable
            ? option1.value
            : option1
          : option2 instanceof Observable
          ? option2.value
          : option2;
      });
    });
  return result$;
};

const cond$ = (...clauses) => {
  const result = clauses
    .map(([test, expression]) => [
      test instanceof Observable ? test.value : test,
      expression instanceof Observable ? expression.value : expression,
    ])
    .reduce((result, [test, expression]) => {
      if (result !== null) return result;
      if (test) return expression;
      return null;
    }, null);

  const result$ = new Observable(result);

  clauses
    .flat()
    .filter((testOrExpression) => testOrExpression instanceof Observable)
    .forEach((testOrExpression) => {
      window.addEventListener(testOrExpression.id, ({ detail }) => {
        const result = clauses
          .map(([test, expression]) => [
            test instanceof Observable ? test.value : test,
            expression instanceof Observable ? expression.value : expression,
          ])
          .reduce((result, [test, expression]) => {
            if (result !== null) return result;
            if (test) return expression;
            return null;
          }, null);
        result$.value = result;
      });
    });

  return result$;
};

const eq$ = (...observables) => {
  const equality = observables
    .map((observable) =>
      observable instanceof Observable ? observable.value : observable
    )
    .every((element, _, array) => element === array[0]);
  const equality$ = new Observable(equality);
  observables.forEach((observable) => {
    window.addEventListener(observable.id, ({ detail }) => {
      const equality = observables
        .map((observable) =>
          observable instanceof Observable ? observable.value : observable
        )
        .every((element, _, array) => element === array[0]);
      equality$.value = equality;
    });
  });
  return equality$;
};

const and$ = (...observables) => {
  const allTruthy = observables
    .map((observable) =>
      observable instanceof Observable ? observable.value : observable
    )
    .every(Boolean);
  const allTruthy$ = new Observable(allTruthy);
  observables.forEach((observable) => {
    window.addEventListener(observable.id, ({ detail }) => {
      const allTruthy = observables
        .map((observable) =>
          observable instanceof Observable ? observable.value : observable
        )
        .every(Boolean);
      allTruthy$.value = allTruthy;
    });
  });
  return allTruthy$;
};

const or$ = (...observables) => {
  const someTruthy = observables
    .map((observable) =>
      observable instanceof Observable ? observable.value : observable
    )
    .some(Boolean);
  const someTruthy$ = new Observable(someTruthy);
  observables
    .filter((observable) => observable instanceof Observable)
    .forEach((observable) => {
      window.addEventListener(observable.id, ({ detail }) => {
        const someTruthy = observables
          .map((observable) =>
            observable instanceof Observable ? observable.value : observable
          )
          .some(Boolean);
        someTruthy$.value = someTruthy;
      });
    });
  return someTruthy$;
};

const not$ = (observable) => {
  const conditional =
    observable instanceof Observable ? observable.value : observable;
  const opposite$ = new Observable(!conditional);
  if (observable instanceof Observable) {
    window.addEventListener(observable.id, ({ detail }) => {
      opposite$.value = !detail;
    });
  }
  return opposite$;
};

const Number$ = (maybeNumber$) => {
  const number$ = new Observable(Number(valueOf$(maybeNumber$)));
  if (isObservable$(maybeNumber$)) {
    window.addEventListener(maybeNumber$.id, () => {
      number$.value = Number(valueOf$(maybeNumber$));
    });
  }
  return number$;
};

const toFixed$ = (number$, decimals$) => {
  const number = number$ instanceof Observable ? number$.value : number$;
  const decimals =
    decimals$ instanceof Observable ? decimals$.value : decimals$;
  const formattedNumber = number.toFixed(decimals);
  const formattedNumber$ = new Observable(formattedNumber);
  [number$, decimals$]
    .filter((observable) => observable instanceof Observable)
    .forEach((observable) => {
      window.addEventListener(observable.id, ({ detail }) => {
        const number = number$ instanceof Observable ? number$.value : number$;
        const decimals =
          decimals$ instanceof Observable ? decimals$.value : decimals$;
        const formattedNumber = number.toFixed(decimals);
        formattedNumber$.value = formattedNumber;
      });
    });
  return formattedNumber$;
};

const slice$ = (stringOrArray$, start$, stop$) => {
  const stringOrArray =
    stringOrArray$ instanceof Observable
      ? stringOrArray$.value
      : stringOrArray$;
  const start = start$ instanceof Observable ? start$.value : start$;
  const stop = stop$ instanceof Observable ? stop$.value : stop$;
  const slicedStringOrArray$ = new Observable(stringOrArray.slice(start, stop));
  [stringOrArray$, start$, stop$]
    .filter((observable) => observable instanceof Observable)
    .forEach((observable) => {
      window.addEventListener(observable.id, ({ detail }) => {
        const stringOrArray =
          stringOrArray$ instanceof Observable
            ? stringOrArray$.value
            : stringOrArray$;
        const start = start$ instanceof Observable ? start$.value : start$;
        const stop = stop$ instanceof Observable ? stop$.value : stop$;
        slicedStringOrArray$.value = stringOrArray.slice(start, stop);
      });
    });
  return slicedStringOrArray$;
};

const length$ = (stringOrArray$) => {
  const length$ = new Observable(valueOf$(stringOrArray$).length);
  if (isObservable$(stringOrArray$)) {
    window.addEventListener(stringOrArray$.id, () => {
      lenth$.value = valueOf$(stringOrArray$).length;
    });
  }
  return length$;
};

const map$ = (array$, function$) => {
  const mappedArray$ = new Observable(
    valueOf$(array$).map(valueOf$(function$))
  );

  [array$, function$].filter(isObservable$).forEach((observable) => {
    window.addEventListener(observable.id, () => {
      mappedArray$.value = valueOf$(array$).map(valueOf$(function$));
    });
  });

  return mappedArray$;
};

const startsWith$ = (includingString$, includedString$) => {
  const includingString =
    includingString$ instanceof Observable
      ? includingString$.value
      : includingString$;

  const includedString =
    includedString$ instanceof Observable
      ? includedString$.value
      : includedString$;

  const includingStringIncludesIncludedString =
    includingString.indexOf(includedString) === 0;

  const includingStringIncludesIncludedString$ = new Observable(
    includingStringIncludesIncludedString
  );

  [includingString$, includedString$]
    .filter((string) => string instanceof Observable)
    .forEach((string) => {
      window.addEventListener(string.id, ({ detail }) => {
        const includingString =
          includingString$ instanceof Observable
            ? includingString$.value
            : includingString$;

        const includedString =
          includedString$ instanceof Observable
            ? includedString$.value
            : includedString$;

        const includingStringIncludesIncludedString =
          includingString.indexOf(includedString) === 0;

        includingStringIncludesIncludedString$.value = includingStringIncludesIncludedString;
      });
    });
  return includingStringIncludesIncludedString$;
};

module.exports = {
  valueOf$,
  isObservable$,
  add$,
  subtract$,
  multiply$,
  divide$,
  choose$,
  cond$,
  eq$,
  and$,
  or$,
  not$,
  Number$,
  toFixed$,
  slice$,
  length$,
  map$,
  startsWith$,
};

  return module.exports;
})();

modules['src/components/textButton/TextButton.js'] = (() => {
  const module = { exports: {} };
  const { button$ } = include('src/libraries/observableHtml/ObservableHtml.js');
const Observable = include('src/libraries/observable/Observable.js');
const { choose$ } = include('src/libraries/observable/utils.js');
const { compose, doPatchChildren } = include(
  'src/libraries/simpleHTML/SimpleHTML.js'
);

const TextButton = (getProps, children) => {
  let isHovered = false;
  const element = compose(
    'button',
    () => ({
      onclick: getProps().onclick,
      onmouseenter: () => {
        isHovered = true;
        element.update();
      },
      onmouseleave: () => {
        isHovered = false;
        element.update();
      },
      style: {
        color: isHovered ? 'darkslategray' : 'slategray',
        height: '64px',
        background: 'white',
        lineHeight: '64px',
        fontSize: '16px',
        width: '100%',
        textAlign: 'center',
        border: 'none',
        outline: 'none',
        cursor: 'pointer',
        padding: '0 16px',
      },
    }),
    children
  );
  return element;
};

module.exports = TextButton;

  return module.exports;
})();

modules['src/views/dataSources/apiUrlInput/ApiUrlInput.js'] = (() => {
  const module = { exports: {} };
  const FullWidthCard = include('src/components/fullWidthCard/FullWidthCard.js');
const ApiInputLabel = include(
  'src/views/dataSources/apiInputLabel/ApiInputLabel.js'
);
const ApiInputContainer = include(
  'src/views/dataSources/apiInputContainer/ApiInputContainer.js'
);
const TextButton = include('src/components/textButton/TextButton.js');
const ApiUrlTestPreview = include(
  'src/views/dataSources/apiUrlTestPreview/ApiUrlTestPreview.js'
);
const { compose, doPatchChildren } = include(
  'src/libraries/simpleHTML/SimpleHTML.js'
);

const ApiUrlInput = (getProps) => {
  const { viewModel } = getProps();
  const element = FullWidthCard({}, [
    compose('div', () => ({ style: { minHeight: '128px' } }), [
      ApiInputLabel(() => ({}), ['API URL']),
      ApiInputContainer(() => ({}), [
        compose(
          'input',
          () => ({
            oninput: ({ value }) => {
              viewModel.updateApiUrl(getProps().state.selectedProjectId, value);
            },
            value: getProps().state.selectedApiUrl,
          }),
          []
        ),
      ]),
      compose(
        'span',
        () => ({
          style: {
            textAlign: 'left',
            width: '192px',
            height: '64px',
            float: 'left',
          },
        }),
        [
          TextButton(
            () => ({
              onclick: getProps().state.testApiUrlInput,
            }),
            ['Test API URL']
          ),
        ]
      ),
      compose('span', () => ({ style: { width: 'calc(100% - 208px)' } }), [
        ApiUrlTestPreview(() => ({}), [
          getProps().state.selectedApiUrlTestPreview,
        ]),
      ]),
    ]),
  ]);
  return element;
};

module.exports = ApiUrlInput;

  return module.exports;
})();

modules['src/views/dataSources/DataSources.js'] = (() => {
  const module = { exports: {} };
  const ApiIntervalInput = include(
  'src/views/dataSources/apiIntervalInput/ApiIntervalInput.js'
);
const { compose } = include('src/libraries/simpleHTML/SimpleHTML.js');
const ApiUrlInput = include('src/views/dataSources/apiUrlInput/ApiUrlInput.js');

// getProps:: () => { viewModel, state }
const DataSources = (getProps) => {
  return compose('div', () => ({}), [
    ApiUrlInput(getProps),
    ApiIntervalInput(getProps),
  ]);
};

module.exports = DataSources;

  return module.exports;
})();

modules['src/libraries/simpleUI/Container.js'] = (() => {
  const module = { exports: {} };
  const { doPatchChildren } = include('src/libraries/simpleHTML/SimpleHTML.js');

const Container = () => {
  // Create base element
  const divElement = document.createElement('div');
  Object.assign(divElement.style, {
    display: 'inline-block',
    width: '100%',
  });

  // Define setters
  Object.defineProperty(divElement, 'widthUnits', {
    set: (widthUnits) => {
      divElement.style.maxWidth = `${widthUnits * 20}px`;
    },
  });
  Object.defineProperty(divElement, 'children', {
    set: (children) => {
      doPatchChildren(divElement, children);
    },
  });
  return divElement;
};

module.exports = Container;

  return module.exports;
})();

modules['src/components/widget/WidgetContainer.js'] = (() => {
  const module = { exports: {} };
  const Container = include('src/libraries/simpleUI/Container.js');

const WidgetContainer = () => {
  const widgetContainer = Container();
  Object.assign(widgetContainer.style, {
    display: 'inline-block',
    verticalAlign: 'top',
    background: 'white',
  });
  return widgetContainer;
};

module.exports = WidgetContainer;

  return module.exports;
})();

modules['src/components/visualization/threeDimVisualization/camera/Camera.js'] = (() => {
  const module = { exports: {} };
  const Observable = include('src/libraries/observable/Observable.js');

const Camera = function({
  target = new Observable([0, 0, 0]),
  horizontalRotation$ = new Observable(0),
  verticalRotation$ = new Observable(0),
  distance$ = new Observabe(100),
  focalLength$ = new Observable(100),
}) {
  this.target = target;
  this.horizontalRotation$ = horizontalRotation$;
  this.verticalRotation$ = new Observable(
    Math.max(Math.min(verticalRotation$.value, Math.PI / 4), -Math.PI / 2)
  );
  this.distance$ = new Observable(
    Math.max(distance$.value, -focalLength$.value / 2)
  );
  this.focalLength$ = focalLength$;
  this.setDistance = distance => {
    this.distance$.value = Math.max(distance, -focalLength$.value / 2);
  };
  this.setVerticalRotation = verticalRotation => {
    this.verticalRotation$.value = Math.max(
      Math.min(verticalRotation, Math.PI / 2),
      -Math.PI / 2
    );
  };
};

module.exports = Camera;

  return module.exports;
})();

modules['src/components/widgetLabel/WidgetLabel.js'] = (() => {
  const module = { exports: {} };
  const { compose } = include('src/libraries/simpleHTML/SimpleHTML.js');

const WidgetLabel = (getProps) => {
  const element = compose(
    'div',
    () => ({
      style: {
        fontSize: '20px',
        marginTop: '20px',
        textAlign: 'center',
        position: 'absolute',
        width: '100%',
        pointerEvents: 'none',
        userSelect: 'none',
      },
    }),
    [getProps().label()]
  );
  element.update = () => {
    element.innerText = getProps().label;
  };
  return element;
};

module.exports = WidgetLabel;

  return module.exports;
})();

modules['src/components/widgetValue/WidgetValue.js'] = (() => {
  const module = { exports: {} };
  const { compose } = include('src/libraries/simpleHTML/SimpleHTML.js');

const WidgetValue = (getProps) => {
  const { value } = getProps();
  const element = compose(
    'div',
    () => ({
      style: {
        fontSize: '60px',
        textAlign: 'center',
        width: '100%',
        position: 'absolute',
        top: '50%',
        transform: 'translate(0, -50%)',
      },
    }),
    [Number(value).toFixed(2)]
  );
  const defaultUpdateFunction = element.update;
  element.update = () => {
    defaultUpdateFunction();
    const { value } = getProps();
    element.innerText = Number(value).toFixed(2);
  };
  return element;
};

module.exports = WidgetValue;

  return module.exports;
})();

modules['src/components/widget/valueWidget/ValueWidget.js'] = (() => {
  const module = { exports: {} };
  const WidgetLabel = include('src/components/widgetLabel/WidgetLabel.js');
const WidgetValue = include('src/components/widgetValue/WidgetValue.js');
const { compose } = include('src/libraries/simpleHTML/SimpleHTML.js');

const ValueWidget = (getProps) => {
  const element = compose(
    'span',
    () => ({
      style: {
        display: 'inline-block',
        position: 'relative',
        color: 'dimgray',
        width: '480px', // 24 x SizeUnit
        height: '320px', // 16 x SizeUnit
        background: Number(getProps().value) === 500 ? 'blue' : 'red',
      },
    }),
    [
      WidgetLabel(() => ({ label: getProps().label })),
      WidgetValue(() => ({ value: getProps().value })),
    ]
  );
  return element;
};

module.exports = ValueWidget;

  return module.exports;
})();

modules['src/components/visualization/render/toCenterOfWidget/toCenterOfWidget.js'] = (() => {
  const module = { exports: {} };
  const toCenterOfWidget = ([x, y, z], ctx) => [
  x + ctx.canvas.width / 2,
  y - ctx.canvas.height / 2,
  z,
];

module.exports = toCenterOfWidget;

  return module.exports;
})();

modules['src/components/visualization/render/toPerspective/toPerspective.js'] = (() => {
  const module = { exports: {} };
  const toPerspective = ([x, y, z], d, focalLength) =>
  focalLength
    ? [
        x * (focalLength / (d + focalLength + z)),
        y * (focalLength / (d + focalLength + z)),
        z,
      ]
    : [x, y, z];

module.exports = toPerspective;

  return module.exports;
})();

modules['src/components/visualization/render/toCenterOfStructure/toCenterOfStructure.js'] = (() => {
  const module = { exports: {} };
  const toCenterOfStructure = ([x, y, z], transformedCenterOfStructure) => [
  x - transformedCenterOfStructure[0],
  y - transformedCenterOfStructure[1],
  z - transformedCenterOfStructure[2],
];

module.exports = toCenterOfStructure;

  return module.exports;
})();

modules['src/components/visualization/render/rotate/rotate.js'] = (() => {
  const module = { exports: {} };
  const rotate = ([x, y, z], rx, ry) => {
  const theta = rx;
  const phi = ry;

  const horizontallyRotatedVertex = [
    x * Math.cos(theta) + z * Math.sin(theta),
    y,
    z * Math.cos(theta) - x * Math.sin(theta),
  ];

  return [
    horizontallyRotatedVertex[0],
    horizontallyRotatedVertex[1] * Math.cos(phi) -
      horizontallyRotatedVertex[2] * Math.sin(phi),
    horizontallyRotatedVertex[1] * Math.sin(phi) +
      horizontallyRotatedVertex[2] * Math.cos(phi),
  ];
};

module.exports = rotate;

  return module.exports;
})();

modules['src/components/widget/doRenderVisualization/doRenderVisualization.js'] = (() => {
  const module = { exports: {} };
  const toCenterOfWidget = include(
  'src/components/visualization/render/toCenterOfWidget/toCenterOfWidget.js'
);
const toPerspective = include(
  'src/components/visualization/render/toPerspective/toPerspective.js'
);
const toCenterOfStructure = include(
  'src/components/visualization/render/toCenterOfStructure/toCenterOfStructure.js'
);
const rotate = include('src/components/visualization/render/rotate/rotate.js');

/**
 * @param {number} dx
 * Defines the x coordinate which will be displayed in the center of the
 * visualization
 *
 * @param {number} dy
 * Defines the y coordinate which will be displayed in the center of the
 * visualization
 *
 * @param {number} dz
 * Defines the z coordinate which will be displayed in the center of the
 * visualization
 *
 * @param {number} d
 * Defines the distance from the defined center of the structure, to the
 * camera.
 */
const doRenderVisualization = ({
  surfaces,
  edges,
  ctx,
  center,
  rx = 0,
  ry = 0,
  d = 0,
  focalLength = 0,
}) => {
  // Render the faces
  surfaces.forEach(({ color, points }) => {
    points
      .map((point) => toCenterOfStructure(point, center))
      .map((point) => rotate(point, rx, ry))
      .map((point) => toPerspective(point, d, focalLength))
      .map((point) => toCenterOfWidget(point, ctx))
      .forEach((point, index) => {
        if (index === 0) {
          ctx.beginPath();
          ctx.moveTo(point[0], -point[1]);
          return;
        }
        if (index < points.length - 1) {
          ctx.lineTo(point[0], -point[1]);
          return;
        }
        if (index === points.length - 1) {
          ctx.lineTo(point[0], -point[1]);
          ctx.closePath();
          ctx.fillStyle = color;
          ctx.fill();
          return;
        }
      });
  });

  // Render the edges
  edges.forEach(({ color, points, width }) => {
    // Draw the first vertex
    const startPoint = toCenterOfWidget(
      toPerspective(
        rotate(toCenterOfStructure(points[0], center), rx, ry),
        d,
        focalLength
      ),

      ctx
    );
    const endPoint = toCenterOfWidget(
      toPerspective(
        rotate(toCenterOfStructure(points[1], center), rx, ry),
        d,
        focalLength
      ),
      ctx
    );
    ctx.beginPath();
    ctx.lineCap = 'round';
    ctx.moveTo(startPoint[0], -startPoint[1]);
    ctx.lineTo(endPoint[0], -endPoint[1]);
    ctx.lineWidth = width;
    ctx.strokeStyle = color;
    ctx.stroke();
  });
};

module.exports = doRenderVisualization;

  return module.exports;
})();

modules['src/components/widget/canvas3dWidget/Canvas3dWidget.js'] = (() => {
  const module = { exports: {} };
  const Observable = include('src/libraries/observable/Observable.js');
const Camera = include(
  'src/components/visualization/threeDimVisualization/camera/Camera.js'
);
const doRenderVisualization = include(
  'src/components/widget/doRenderVisualization/doRenderVisualization.js'
);
const { compose } = include('src/libraries/simpleHTML/SimpleHTML.js');

// TODO: Shouldn't there be a label here?
const Canvas3dWidget = (getProps) => {
  const { surfaces, edges, center } = getProps();
  const state = { mouseDown: false };
  const canvasElement = compose(
    'canvas',
    () => ({
      height: 320, // 16 x SizeUnit
      width: 480, // 24 x SizeUnit
      style: { position: 'absolute' },
    }),
    []
  );
  const camera = new Camera({
    horizontalRotation$: new Observable(0),
    verticalRotation$: new Observable(0),
    distance$: new Observable(100),
    focalLength$: new Observable(100),
  });
  const ctx = canvasElement.getContext('2d');
  const rerender = () => {
    const { surfaces, edges, center } = getProps();
    ctx.clearRect(0, 0, canvasElement.width, canvasElement.height);
    doRenderVisualization({
      surfaces,
      edges,
      ctx,
      center,
      rx: camera.horizontalRotation$.value,
      ry: camera.verticalRotation$.value,
      d: camera.distance$.value,
      focalLength: camera.focalLength$.value,
    });
  };
  rerender();
  canvasElement.onwheel = (event) => {
    camera.setDistance(camera.distance$.value + event.deltaY / 5);
  };
  window.addEventListener('mousedown', (event) => {
    state.mouseDown = true;
  });
  window.addEventListener(
    'mouseup',
    (canvasElement.onmouseup = (event) => {
      state.mouseDown = false;
    })
  );
  canvasElement.onmousemove = (event) => {
    if (state.mouseDown) {
      camera.horizontalRotation$.value =
        camera.horizontalRotation$.value - event.movementX / 100;
      camera.setVerticalRotation(
        camera.verticalRotation$.value - event.movementY / 100
      );
    }
  };
  canvasElement.update = ({ surfaces, edges, center }) => {
    rerender({ surfaces, edges, center });
  };
  window.addEventListener(camera.horizontalRotation$.id, () => {
    rerender({ surfaces, edges, center });
  });
  window.addEventListener(camera.verticalRotation$.id, () => {
    rerender({ surfaces, edges, center });
  });
  window.addEventListener(camera.distance$.id, () => {
    rerender({ surfaces, edges, center });
  });
  window.addEventListener(camera.focalLength$.id, () => {
    rerender({ surfaces, edges, center });
  });
  return canvasElement;
};

module.exports = Canvas3dWidget;

  return module.exports;
})();

modules['src/components/widget/canvas2dWidget/Canvas2dWidget.js'] = (() => {
  const module = { exports: {} };
  const doRenderVisualization = include(
  'src/components/widget/doRenderVisualization/doRenderVisualization.js'
);
const { compose } = include('src/libraries/simpleHTML/SimpleHTML.js');

// TODO: Shouldn't there be a label here?
const TwoDimVisualization = ({ surfaces, edges, is3d, center }) => {
  const canvasElement = compose(
    'canvas',
    {
      height: 320, // 16 x SizeUnit
      width: 480, // 24 x SizeUnit
      style: { position: 'absolute' },
    },
    []
  );
  const ctx = canvasElement.getContext('2d');
  const rerender = ({ surfaces, edges, center }) => {
    ctx.clearRect(0, 0, canvasElement.width, canvasElement.height);
    doRenderVisualization({ surfaces, edges, center, ctx });
  };
  rerender({ surfaces, edges, center });
  canvasElement.update = ({ surfaces, edges, center }) => {
    rerender({ surfaces, edges, center });
  };
  return canvasElement;
};

module.exports = TwoDimVisualization;

  return module.exports;
})();

modules['src/components/widget/Widget.js'] = (() => {
  const module = { exports: {} };
  const WidgetContainer = include('src/components/widget/WidgetContainer.js');
const Canvas3dWidget = include(
  'src/components/widget/canvas3dWidget/Canvas3dWidget.js'
);
const Canvas2dWidget = include(
  'src/components/widget/canvas2dWidget/Canvas2dWidget.js'
);
const ValueWidget = include('src/components/widget/valueWidget/ValueWidget.js');
const { compose, doPatchChildren } = include(
  'src/libraries/simpleHTML/SimpleHTML.js'
);

/**
 *
 * @param {{
 *   type: 'canvas-widget' | 'value-widget';
 *   label: string;
 *   value: number;
 *   surfaces: { color: string, points: [number, number, number][] }[];
 *   edges: [[number, number, number][]];
 *   center: [number, number, number];
 *   is3d: boolean;
 * }} props
 *
 * @returns { HTMLElement }
 */
const getWidgetElementByType = (props) => {
  if (props.type === 'canvas-widget') {
    return props.is3d ? Canvas3dWidget(props) : Canvas2dWidget(props);
  }
  if (props.type === 'value-widget') {
    return ValueWidget(props);
  }
  throw Error('A widget must have type canvas-widget or value-widget');
};

/**
 *
 * @param {{
 *   type: 'canvas-widget' | 'value-widget';
 *   label: string;
 *   value: number;
 *   surfaces: { color: string, points: [number, number, number][] }[];
 *   edges: [[number, number, number][]];
 *   center: [number, number, number];
 *   is3d: boolean;
 * }} props
 *
 * @returns { HTMLElement }
 */
const Widget = (props) => {
  const previousProps = props;
  const element = compose(
    'span',
    {
      style: {
        padding: '10px',
        display: 'inline-block',
        verticalAlign: 'top',
        background: 'white',
        width: '480px', // 24 x SizeUnit
        height: '320px', // 16 x SizeUnit
        boxShadow: 'rgba(0, 0, 0, 0.25) 0 0 10px -5px',
      },
    },
    [getWidgetElementByType(props)]
  );
  element.update = (newProps) => {
    if (newProps.type == previousProps.type) {
      element.childNodes[0].update(newProps);
    } else {
      doPatchChildren(element, [getWidgetElementByType(props)]);
    }
    Object.assign(previousProps, newProps);
  };
  return element;
};

module.exports = Widget;

  return module.exports;
})();

modules['src/components/dashboardWidgets/DashboardWidgets.js'] = (() => {
  const module = { exports: {} };
  const Widget = include('src/components/widget/Widget.js');
const { compose } = include('src/libraries/simpleHTML/SimpleHTML.js');

const getWidgetElements = ({ widgets }) => {
  return widgets.map(
    ({ type, label, value, surfaces, edges, is3d, center }) => {
      return Widget(() => ({
        type,
        label,
        value,
        surfaces,
        edges,
        is3d,
        center,
      }));
    }
  );
};

// getProps::() => { state, viewModel }
const DashboardWidgets = (getProps) => {
  const element = compose(
    'div',
    () => ({ style: { padding: '10px' } }),
    getWidgetElements({ widgets: getProps().state.widgets })
  );
  element.update = () => {
    const { state } = getProps();
    if (state.widgets.length !== element.childElementCount) {
      doPatchChildren(
        element,
        getWidgetElements({ widgets: getProps().state.widgets })
      );
    } else {
      Array.from(element.childNodes).forEach((childNode) => {
        childNode.update();
      });
    }
  };
  return element;
};

module.exports = DashboardWidgets;

  return module.exports;
})();

modules['src/views/dashboard/Dashboard.js'] = (() => {
  const module = { exports: {} };
  const DashboardWidgets = include(
  'src/components/dashboardWidgets/DashboardWidgets.js'
);
const { compose } = include('src/libraries/simpleHTML/SimpleHTML.js');

const Dashboard = (getProps) => {
  const element = compose('div', () => ({ style: { padding: '10px' } }), [
    DashboardWidgets(getProps),
  ]);

  return element;
};

module.exports = Dashboard;

  return module.exports;
})();

modules['src/views/dashboardEditor/DashboardEditor.js'] = (() => {
  const module = { exports: {} };
  const DashboardWidgets = include(
  'src/components/dashboardWidgets/DashboardWidgets.js'
);
const { compose } = include('src/libraries/simpleHTML/SimpleHTML.js');

const CodeEditor = (getProps) => {
  const element = compose('div', () => ({ style: { padding: '10px' } }), [
    compose(
      'textarea',
      () => {
        const { value, oninput } = getProps();
        return {
          oninput,
          style: {
            height: '300px',
            borderRadius: '5px',
            fontFamily: `"Courier New", Courier, monospace`,
            background: 'rgba(0, 0, 0, 0.05)',
            outline: 'none',
            fontSize: '15px',
            padding: '10px',
            border: 'none',
            resize: 'none',
            width: '100%',
            boxShadow: 'inset rgba(0, 0, 0, 0.5) 0 0 10px -5px',
          },
          value,
        };
      },
      []
    ),
  ]);
  element.update = ({ value, oninput }) => {
    element.childNodes[0].value = value;
    element.childNodes[0].oninput = oninput;
  };
  return element;
};

// getProps::() => { state, viewModel }
const DashboardEditor = (getProps) => {
  const { state, viewModel } = getProps();
  const value = state.selectedWidgetsCode;
  const oninput = ({ target }) => {
    viewModel.updateWidgetsCode(state.selectedProjectId, target.value);
  };

  const element = compose('div', () => ({ style: { padding: '10px' } }), [
    CodeEditor(() => ({ value, oninput })),
    DashboardWidgets(getProps),
  ]);

  return element;
};

module.exports = DashboardEditor;

  return module.exports;
})();

modules['src/app/App.js'] = (() => {
  const module = { exports: {} };
  const ProjectNavigator = include(
  'src/views/project/projectNavigator/ProjectNavigator.js'
);
const ProjectContainer = include(
  'src/views/project/projectContainer/ProjectContainer.js'
);
const TitleBar = include('src/app/titleBar/TitleBar.js');
const Projects = include('src/views/projects/Projects.js');
const DataSources = include('src/views/dataSources/DataSources.js');
const Dashboard = include('src/views/dashboard/Dashboard.js');
const DashboardEditor = include('src/views/dashboardEditor/DashboardEditor.js');

const { compose } = include('src/libraries/simpleHTML/SimpleHTML.js');

// getProps::() => { state, viewModel }
const App = (getProps) => {
  const { state } = getProps();
  console.log('getProps().state.currentRoute: ', getProps().state.currentRoute);
  const element = state.isExported
    ? compose('div', () => ({}), [
        TitleBar(getProps),
        ProjectContainer({}, [Dashboard(getProps)]),
      ])
    : compose('div', () => ({}), [
        TitleBar(getProps),
        getProps().state.currentRoute === '/' ? Projects(getProps) : null,
        getProps().state.currentRoute.indexOf(
          '/projects/<projectId:string>'
        ) === 0
          ? ProjectContainer(() => ({}), [
              ProjectNavigator(() => ({ state: getProps().state })),
              state.currentRoute ===
                '/projects/<projectId:string>/data-sources' ||
              state.currentRoute === '/projects/<projectId:string>'
                ? DataSources(getProps)
                : null,
              state.currentRoute ===
              '/projects/<projectId:string>/dashboard/edit'
                ? DashboardEditor(getProps)
                : null,
              state.currentRoute === '/projects/<projectId:string>/dashboard'
                ? Dashboard(getProps)
                : null,
            ])
          : null,
      ]);
  // TODO: Add some custom update logic to make sure children are replaced if route changes
  return element;
};

module.exports = App;

  return module.exports;
})();

window.addEventListener('load', () => {
const Router = include('src/libraries/simpleRouter/SimpleRouter.js');
const simpleState = include('src/libraries/simpleState/SimpleState.js');
const Model = include('src/model/Model.js');
const App = include('src/app/App.js');

Object.assign(document.body.style, {
  margin: 0,
  fontFamily: 'sans-serif',
  background: 'GhostWhite',
  height: '100%',
});
//const FIREBASE_API_KEY = 'AIzaSyCeGXLqw0MEwiSFHG1Wks1HfQHXRZoOuFY';

const isExported = false;

// Create router
const router = isExported
  ? new Router({
      '/': 'Dashboard',
    })
  : new Router({
      '/': 'Projects',
      '/projects/<projectId:string>': 'Data sources',
      '/projects/<projectId:string>/data-sources': 'Data sources',
      '/projects/<projectId:string>/values': 'Values',
      '/projects/<projectId:string>/values/edit': 'Edit values',
      '/projects/<projectId:string>/dashboard': 'Dashboard',
      '/projects/<projectId:string>/dashboard/edit': 'Edit dashboard',
    });

const { state, setState, addStateChangeListener } = simpleState({
  currentRoute: router.currentRoute,
  params: router.params,
  isExported,
  projects: [],
  selectedProjectId: null,
  selectedProjectName: '',
  lastVisitedProjectView: null,
  selectedApiUrl: '',
  selectedApiUrlTestPreview: '',
  selectedApiInterval: null,
  apiResponse: '',
  selectedDerivedValuesCode: '',
  selectedWidgetsCode: '',
  widgets: [],
});

const viewModel = Model({ router, isExported, state, setState });

const app = App(() => ({
  state,
  setState,
  viewModel,
}));
addStateChangeListener(({ state, setState }) => app.update());

document.body.appendChild(app);

})
</script>