
<meta charset="utf-8" />
<script>
const modules = {}
const include = path => modules[path];

modules['src/libraries/simpleRouter/SimpleRouter.js'] = (() => {
  const module = { exports: {} };
  function SimpleRouter(routes) {
  /**
   * @param {string} routes
   */
  this.setRoutes = function (routes) {
    Object.entries(routes).forEach(([route, title]) => {
      this.routes[route] = route;
      this.titles[route] = title;
      if (route === '/') {
        this.routes[''] = route;
        this.titles[''] = title;
      }
    });
    this.syncWithHash();
  };
  SimpleRouter.getTokens = function (hash) {
    return hash
      .split('/')
      .filter(Boolean)
      .filter((element) => element !== '#')
      .filter((element) => element !== '#!');
  };
  /**
   * @param {string} token
   * @returns {boolean}
   */
  SimpleRouter.isParameterRouteToken = function (token) {
    if (
      token.indexOf('<') !== 0 ||
      !token.slice(2, -4).includes(':') ||
      token.indexOf('>') !== token.length - 1
    ) {
      return false;
    }
    const [parameter, type] = token
      .slice(token.indexOf('<') + 1, token.indexOf('>'))
      .split(':');

    if (!['int', 'string', 'number'].includes(type)) {
      return false;
    }
    return true;
  };
  SimpleRouter.appendTokenToHash = function (hash, token) {
    return `${hash}/${token}`;
  };
  SimpleRouter.parseParameterRouteToken = function (token) {
    const [parameter, type] = token
      .slice(token.indexOf('<') + 1, token.indexOf('>'))
      .split(':');
    return {
      parameter,
      type,
    };
  };
  // (hash: string, route: string) => false | { [key: string]: number | string }
  SimpleRouter.getMatch = function (hash, route) {
    const hashTokens = SimpleRouter.getTokens(hash);
    const routeTokens = SimpleRouter.getTokens(route);
    const params = {};
    let reconstructedHash = '#!';
    if (hashTokens.length !== routeTokens.length) return false;
    for (let i of Object.keys(hashTokens)) {
      const hashToken = hashTokens[i];
      const routeToken = routeTokens[i];
      if (SimpleRouter.isParameterRouteToken(routeToken)) {
        const { parameter, type } = SimpleRouter.parseParameterRouteToken(
          routeToken
        );
        if (type === 'int') {
          if (!Router.isInt(hashToken)) return false;
          params[parameter] = parseInt(hashToken);
          reconstructedHash = SimpleRouter.appendTokenToHash(
            reconstructedHash,
            hashToken
          );
        } else if (type === 'number' && !Router.isNumber(hasToken)) {
          if (!Router.isNumber(hashToken)) return false;
          params[parameter] = Number(hashToken);
          reconstructedHash = SimpleRouter.appendTokenToHash(
            reconstructedHash,
            hashToken
          );
        } else if (type === 'string') {
          params[parameter] = hashToken;
          reconstructedHash = SimpleRouter.appendTokenToHash(
            reconstructedHash,
            hashToken
          );
        }
      } else {
        if (hashToken !== routeToken) return false;
        reconstructedHash = SimpleRouter.appendTokenToHash(
          reconstructedHash,
          hashToken
        );
      }
    }
    return { params, reconstructedHash };
  };
  SimpleRouter.getRouteAndParamsFromHash = function (hash, routes) {
    for (let route of Object.keys(routes)) {
      const match = SimpleRouter.getMatch(hash, route);
      if (match) {
        const { params, reconstructedHash } = match;
        return { route, params, reconstructedHash };
      }
    }
    return { route: '', params: {}, reconstructedHash: '' };
  };
  /**
   * @param {Object.<string, number | string>} params
   */
  this.setParams = function (params) {
    this.params = params;
    // Todo: Maybe dispatch some kind of event
  };
  this.setCurrentRoute = function (route) {
    this.currentRoute = route;
  };
  this.setCurrentTitle = function (title) {
    this.currentTitle = title;
  };
  SimpleRouter.removeHash = function () {
    return history.replaceState(null, null, ' ');
  };
  this.syncWithHash = function () {
    const { hash } = location;
    const {
      route,
      params,
      reconstructedHash,
    } = SimpleRouter.getRouteAndParamsFromHash(hash, this.routes);
    this.setParams(params);
    this.setCurrentRoute(this.routes[route]);
    this.setCurrentTitle(this.titles[route]);
    if (reconstructedHash === '#!') {
      SimpleRouter.removeHash();
    } else {
      history.replaceState(undefined, undefined, reconstructedHash);
    }
    document.title = this.currentTitle;
  };
  this.params = {};
  this.currentRoute = '';
  this.routes = {};
  this.titles = {};
  this.hashChangeListeners = [];
  this.setRoutes(routes);
  window.addEventListener('hashchange', () => {
    this.syncWithHash();
    this.callHashChangeListeners();
  });
  /**
   * @param {string} route
   * One of the registered routes, without hashbang
   */
  this.navigateTo = (route) => {
    location.hash = `#!${route}`;
  };

  this.refresh = () => this.syncWithHash();

  // @possiblyNumber: string
  SimpleRouter.isNumber = function (possiblyNumber) {
    return !isNaN(Number(possiblyNumber));
  };
  SimpleRouter.isInt = function (possiblyInt) {
    return (
      SimpleRouter.isNumber(possiblyInt) &&
      parseInt(possiblyInt) === Number(possiblyInt)
    );
  };
  this.onHashChange = (callback) => {
    this.hashChangeListeners.push(callback);
    this.callHashChangeListeners();
  };
  this.callHashChangeListeners = () => {
    this.hashChangeListeners.forEach((hashChangeListener) =>
      hashChangeListener({
        params: this.params,
        currentRoute: this.currentRoute,
      })
    );
  };
  this.getParams = () => this.params;
  this.getCurrentTitle = () => this.currentTitle;
  SimpleRouter.isProp = (propsOrChild) =>
    !(propsOrChild instanceof HTMLElement || typeof propsOrChild === 'string');
}

module.exports = SimpleRouter;

  return module.exports;
})();

modules['src/libraries/simpleState/SimpleState.js'] = (() => {
  const module = { exports: {} };
  const simpleState = (initialState) => {
  const state = initialState;
  const stateChangeCallbacks = [];
  const emit = () => {
    stateChangeCallbacks.forEach((stateChangeCallback) => {
      stateChangeCallback({ state, setState });
    });
  };
  const setState = (newState) => {
    Object.assign(state, newState);
    emit();
  };
  const addStateChangeListener = (stateChangeCallback) => {
    const element = { state, setState };
    stateChangeCallbacks.push(stateChangeCallback);
    return element;
  };
  return {
    state,
    setState,
    addStateChangeListener,
  };
};

module.exports = simpleState;

  return module.exports;
})();

modules['src/libraries/simpleHTML/SimpleHTML.js'] = (() => {
  const module = { exports: {} };
  const doAddInnerShadow = (element) => {
  element.style.boxShadow = 'inset rgba(0, 0, 0, 0.25) 0 0 10px -5px';
};

const doAddShadow = (element) => {
  element.style.boxShadow = 'rgba(0, 0, 0, 0.25) 0 0 10px -5px';
};

const doPatchChildren = (
  element,
  newChildren,
  compareFunction = (a, b) => a === b
) => {
  newChildren.forEach((newChild, index) => {
    // If the new child node already exists on the correct index, jump to next iteration
    if (compareFunction(newChild, element.childNodes[index])) return;

    // As long as there is an old child node at the current index which does not correspond to any of the new childNodes, remove it
    while (
      element.childNodes[index] &&
      !newChildren.some((newChild) =>
        compareFunction(newChild, element.childNodes[index])
      )
    ) {
      element.removeChild(element.childNodes[index]);
    }

    // Insert the new child node at the correct position
    if (element.childNodes[index]) {
      element.insertBefore(newChild, element.childNodes[index]);
      return;
    }
    // TODO: Find out why this is needed
    if (!(newChild.contains && newChild.contains(element))) {
      element.append(newChild);
    }
    return;
  });

  // Remove any superfluous old nodes which don't correspond to the new nodes
  while (newChildren.length < element.childNodes.length) {
    element.removeChild(element.childNodes[newChildren.length]);
  }
};

const flatten = (items) => {
  const flat = [];

  items.forEach((item) => {
    if (Array.isArray(item)) {
      flat.push(...flatten(item));
    } else {
      flat.push(item);
    }
  });

  return flat;
};

const compose = (elementType, getProps, children) => {
  const element = document.createElement(elementType);

  // Assign props
  if (typeof getProps === 'function') {
    Object.assign(element, getProps());
  } else {
    Object.assign(element, getProps);
  }

  // Append children
  element.append(...flatten(children).filter(Boolean));

  element.update = () => {
    // We update the props only if they are provided as a function. Otherwise they are static.
    if (typeof getProps === 'function') {
      if (element.setSelectionRange) {
        const { selectionStart, selectionEnd } = element;
        element.setSelectionRange(selectionStart, selectionEnd);
      } else {
        Object.assign(element, getProps());
      }
    }

    Array.from(element.childNodes).forEach((childNode) => {
      // We check that the parent node exists because a previous sibling might
      // be a logic element which has unmounted a later element
      if (typeof childNode.update === 'function' && childNode.parentNode) {
        childNode.update();
      }
    });
  };
  return element;
};

const createContentsContainer = () => {
  const element = Object.assign(document.createElement('div'), {
    style: 'display: contents;',
  });
  return element;
};

const Each = (getArray, mappingFunction) => {
  const logicElement = createContentsContainer();
  let array = getArray();
  const childNodes = flatten(
    array.map((_, i) =>
      mappingFunction(
        () => getArray()[i],
        () => i,
        getArray
      )
    )
  );

  logicElement.append(...childNodes);

  logicElement.update = () => {
    const newArray = getArray();

    if (newArray.length === array.length) {
      Array.from(logicElement.childNodes).forEach((childNode) => {
        if (typeof childNode.update === 'function') {
          childNode.update();
        }
      });
      return;
    }

    // If some elements should be added
    if (newArray.length > array.length) {
      Array.from(logicElement.childNodes).forEach((childNode) => {
        if (typeof childNode.update === 'function') {
          childNode.update();
        }
      });

      const newChildNodes = flatten(
        newArray.slice(array.length).map((_, _i) => {
          const i = _i + array.length;
          return mappingFunction(
            () => getArray()[i],
            () => i,
            getArray
          );
        })
      );

      logicElement.append(...newChildNodes);

      array = newArray;
      return;
    }

    // If some elements should be removed
    if (newArray.length < array.length) {
      // Even if we already have nodes which can be updated to match the new
      // child nodes, we need to see how many nodes we should keep, since each
      // item in the array can potentially be mapped to several nodes.
      const newChildNodes = flatten(
        newArray.map((_, i) =>
          mappingFunction(
            () => getArray()[i],
            () => i,
            getArray
          )
        )
      );

      // Remove superfluous nodes
      const childrenToBeRemoved = Array.from(logicElement.childNodes).slice(
        newChildNodes.length
      );
      childrenToBeRemoved.forEach((childNodeToBeRemoved) => {
        logicElement.removeChild(childNodeToBeRemoved);
      });

      // Update variables
      array = newArray;

      // Update current child nodes
      Array.from(logicElement.childNodes).forEach((childNode) => {
        if (typeof childNode.update === 'function') {
          childNode.update();
        }
      });
    }
  };

  return logicElement;
};

const If = (getCondition, getThenChildNodes, getElseChildNodes = () => []) => {
  const logicElement = createContentsContainer();
  let condition = getCondition();
  const childNodes = condition
    ? flatten(getThenChildNodes()).filter(Boolean)
    : flatten(getElseChildNodes()).filter(Boolean);

  logicElement.append(...childNodes);

  logicElement.update = () => {
    if (condition && getCondition()) {
      Array.from(logicElement.childNodes).forEach((childNode) => {
        if (typeof childNode.update === 'function') {
          childNode.update();
        }
      });
      return;
    }
    if (!condition && getCondition()) {
      condition = true;
      const thenChildNodes = flatten(getThenChildNodes()).filter(Boolean);
      // Remove the old children
      logicElement.innerHTML = '';

      // Add the new children after the logic element
      logicElement.append(...thenChildNodes);
      return;
    }
    if (condition && !getCondition()) {
      condition = false;
      const elseChildNodes = flatten(getElseChildNodes()).filter(Boolean);
      // Remove the old children
      logicElement.innerHTML = '';

      // Add the new children
      logicElement.append(...elseChildNodes);
      return;
    }
  };
  return logicElement;
};

class SimpleHTML {
  static isProp = (propsOrChild) =>
    !(propsOrChild instanceof HTMLElement || typeof propsOrChild === 'string');
  static makeElement(elementType, propsOrChild, ...maybeAllChildren) {
    const element = document.createElement(elementType);
    const hasProps = SimpleHTML.isProp(propsOrChild);
    const props = hasProps ? propsOrChild || {} : {};
    const children = hasProps
      ? maybeAllChildren
      : [propsOrChild, ...maybeAllChildren];
    Object.entries(props).forEach(([attribute, value]) => {
      if (attribute === 'style') {
        Object.assign(element.style, value);
      } else if (attribute === 'onClick') {
        element.onclick = value;
      } else if (attribute === 'onInput') {
        element.oninput = value;
      } else {
        element[attribute] = value;
      }
    });
    children
      .filter(Boolean)
      .map((child) =>
        typeof child === 'string' ? document.createTextNode(child) : child
      )
      .forEach((child) => {
        element.appendChild(child);
      });
    return element;
  }
}

const doMerge = (oldElement, newElement) => {
  if (!oldElement.parentNode) return;

  const oldChildren = Array.from(oldElement.childNodes);
  const newChildren = Array.from(newElement.childNodes);
  newChildren.forEach((newChild, i) => {
    let foundMatchingOldChild = false;
    while (oldChildren.length && !foundMatchingOldChild) {
      oldChild = oldChildren.shift();
      if (
        oldChild.component === newChild.component &&
        oldChild instanceof Element
      ) {
        const selectionStart = oldChild.selectionStart;
        const selectionEnd = oldChild.selectionEnd;
        oldChild.value = newChild.value;
        oldChild.selectionStart = selectionStart;
        oldChild.selectionEnd = selectionEnd;

        oldChild.update(...newChild.propsAndChildren);
        if (Object.keys(newChild.propsAndChildren[0]).includes('style')) {
          if (!oldChild.style) {
            Object.keys(oldChild.parentNode.style).forEach((property) => {
              if (!newChild.propsAndChildren[0].style[property]) {
                oldChild.parentNode.style[property] = null;
              }
            });
            Object.assign(
              oldChild.parentNode.style,
              newChild.propsAndChildren[0].style
            );
          } else {
            Object.keys(oldChild.parentNode.style).forEach((property) => {
              if (!newChild.propsAndChildren[0].style[property]) {
                oldChild.style[property] = null;
              }
            });
            Object.assign(oldChild.style, newChild.propsAndChildren[0].style);
          }
        }
        oldChild.innerText = newChild.innerText;

        foundMatchingOldChild = true;
      } else if (
        !(oldChild instanceof Element) &&
        !(newChild instanceof Element)
      ) {
        if (oldChild.data === newChild.data) {
          foundMatchingOldChild = true;
        } else {
          oldChild.data = newChild.data;
        }
        foundMatchingOldChild = true;
      } else {
        oldElement.removeChild(oldChild);
      }
    }
    if (!foundMatchingOldChild) {
      while (oldElement.childNodes[i]) {
        oldElement.removeChild(oldElement.childNodes[i]);
      }
      oldElement.appendChild(newChild);
    }
  });
  while (newChildren.length < oldElement.childNodes.length) {
    oldElement.removeChild(oldElement.childNodes[newChildren.length]);
  }
};

const defineComponent = (elementFunction) => {
  const component = (...propsAndChildren) => {
    const element = elementFunction(...propsAndChildren);
    element.component = component;
    element.propsAndChildren = propsAndChildren;
    element.update = (...newPropsAndChildren) => {
      element.propsAndChildren = newPropsAndChildren;
      doMerge(element, component(...newPropsAndChildren));
    };
    return element;
  };
  return component;
};

const div = defineComponent((props, ...children) =>
  SimpleHTML.makeElement('div', props, ...children)
);

const span = defineComponent((props, ...children) =>
  SimpleHTML.makeElement('span', props, ...children)
);

const a = defineComponent((props, ...children) =>
  SimpleHTML.makeElement('a', props, ...children)
);

const p = defineComponent((props, ...children) =>
  SimpleHTML.makeElement('p', props, ...children)
);

const h1 = defineComponent((props, ...children) =>
  SimpleHTML.makeElement('h1', props, ...children)
);

const h2 = defineComponent((props, ...children) =>
  SimpleHTML.makeElement('h2', props, ...children)
);

const img = defineComponent((props, ...children) =>
  SimpleHTML.makeElement('img', props, ...children)
);

const form = defineComponent((props, ...children) =>
  SimpleHTML.makeElement('form', props, ...children)
);

const input = defineComponent((props) =>
  SimpleHTML.makeElement('input', props)
);

const textarea = defineComponent((props) =>
  SimpleHTML.makeElement('textarea', props)
);

const br = defineComponent((props, ...children) =>
  SimpleHTML.makeElement('br', props, ...children)
);

const button = defineComponent((props, ...children) =>
  SimpleHTML.makeElement('button', props, ...children)
);
// And so on, fill in more as needed...

module.exports = {
  doMerge,
  compose,
  Each,
  If,
  defineComponent,
  div,
  span,
  a,
  p,
  h1,
  h2,
  img,
  form,
  input,
  textarea,
  br,
  button,
  doAddInnerShadow,
  doAddShadow,
  doPatchChildren,
};

  return module.exports;
})();

modules['src/data/Data.js'] = (() => {
  const module = { exports: {} };
  const getAllProjects = () => {
  const projects = JSON.parse(localStorage.getItem('projects')) || [];
  return projects.map(
    ({ id, name, apiUrl, apiInterval, derivedValuesCode, widgetsCode }) => ({
      id: id || '',
      name: name || '',
      apiUrl: apiUrl || '',
      apiInterval: apiInterval || 0,
      derivedValuesCode: derivedValuesCode || '',
      widgetsCode: widgetsCode || '',
    })
  );
};

const getExportedProject = () => [];

const getProjectById = (projectIdId) =>
  JSON.parse(localStorage.getItem('projects')).find(
    ({ id }) => id == projectId
  );

const createProject = (newProject) => {
  const projects = getAllProjects();
  const projectsUpdated = [
    ...projects,
    {
      ...newProject,
      id: `${Math.random()}${+new Date()}`,
    },
  ];
  localStorage.setItem('projects', JSON.stringify(projectsUpdated));
};

const updateProjectById = (projectId, project) => {
  const projects = getAllProjects();
  const projectIndex = projects.findIndex(({ id }) => id === projectId);
  if (projectIndex === -1) {
    console.warn('Tried to update nonexistent project');
    return;
  }
  Object.assign(projects[projectIndex], project);
  localStorage.setItem('projects', JSON.stringify(projects));
};

const deleteProjectById = (projectId) => {
  const projects = getAllProjects();
  const updatedProjects = projects.filter(({ id }) => id !== projectId);
  localStorage.setItem('projects', JSON.stringify(updatedProjects));
};

module.exports = {
  getAllProjects,
  getExportedProject,
  getProjectById,
  createProject,
  updateProjectById,
  deleteProjectById,
};

  return module.exports;
})();

modules['src/libraries/languageParser/LanguageParser.js'] = (() => {
  const module = { exports: {} };
  /**
 * Checks if the expression has an opening and closing parenthesis
 * @param {string} expression
 */
const isExpression = (expression) => {
  if (expression.length < 2) return false;
  if (expression.charAt(0) !== '(') return false;
  if (expression.slice(-1) !== ')') return false;
  return true;
};

/**
 * Removes the first and the last character from an expression.
 * It is assumed that these those characters are parentheses.
 * @param {string} expression
 */
const trimParentheses = (expression) => expression.slice(1, -1);

/**
 * Removes the first and the last character from an expression.
 * It is assumed that these those characters are singleQuotes.
 * @param {string} expression
 */
const trimSingleQuotes = (expression) => expression.slice(1, -1);

/**
 * Removes the first and the last character from an expression.
 * It is assumed that these those characters are square brackets.
 * @param {string} expression
 */
const trimSquareBrackets = (expression) => expression.slice(1, -1);

/**
 * Removes the first and the last character from an expression.
 * It is assumed that these those characters are curly brackets.
 * @param {string} expression
 */
const trimCurlyBrackets = (expression) => expression.slice(1, -1);

/**
 * Checks if the expression has an opening and closing single quote
 * @param {string} expression
 */
const isString = (expression) => {
  if (expression.length < 2) return false;
  if (expression.charAt(0) !== "'") return false;
  if (expression.slice(-1) !== "'") return false;
  return true;
};

/**
 * Checks if the expression has an opening and opening and closing square bracket
 * @param {string} expression
 */
const isArray = (expression) => {
  if (expression.length < 2) return false;
  if (expression.charAt(0) !== '[') return false;
  if (expression.slice(-1) !== ']') return false;
  return true;
};

/**
 * Checks if the expression has an opening and opening and closing curly bracket
 * @param {string} expression
 */
const isObject = (expression) => {
  if (expression.length < 2) return false;
  if (expression.charAt(0) !== '{') return false;
  if (expression.slice(-1) !== '}') return false;
  return true;
};

/**
 * Checks if the expression can be interpreted as a number
 * @param {string} expression
 */
const isNumber = (expression) => !isNaN(Number(expression));

/**
 * Checks if the expression is a valid name to be bound to a value
 * @param {string} expression
 */
const isWord = (expression) => true; // TODO: Define what is a valid name of a value

/**
 * Checks if the expression is a boolean
 * @param {string} expression
 */
const isBoolean = (expression) =>
  expression === 'true' || expression === 'false';

/**
 * Checks if the token is a valid keyword, i.e. starts with a colon
 * @param {string} token
 */
const isKeyword = (token) =>
  token.charAt(0) === ':' && !token.slice(1).includes(':');

/**
 * Removes the colon from the start of the keyword
 * Assumes that the keyword is a valid keyword, i.e. starts with a colon
 * @param {string} token
 */
const removeColonFromKeyword = (keyword) => {
  if (!isKeyword(keyword)) {
    throw SyntaxError(`A keyword must be preceded by a colon: ${keyword}`);
  }
  return keyword.slice(1);
};

/**
 * Checks if the expression is a boolean
 * @param {'true' | 'false'} expression
 */
const parseBoolean = (expression) => (expression === 'true' ? true : false);

/**
 * Takes a string of one or more expressions and splits it into tokens at
 * whitespaces which are not inside strings nor parentheses
 * @param {string} expression
 * @returns {string[]}
 */
const getTokens = (expression) => {
  word = '';
  parenthesesCount = 0;
  squareBracketCount = 0;
  curlyBracketCount = 0;
  isInsideString = false;
  expression.split('').forEach((char) => {
    if (char === '(' && !isInsideString) {
      parenthesesCount++;
      word += '(';
      return;
    }
    if (char === '[' && !isInsideString) {
      squareBracketCount++;
      word += '[';
      return;
    }
    if (char === '{' && !isInsideString) {
      curlyBracketCount++;
      word += '{';
      return;
    }
    if (char === ')' && !isInsideString) {
      parenthesesCount--;
      word += ')';
      return;
    }
    if (char === ']' && !isInsideString) {
      squareBracketCount--;
      word += ']';
      return;
    }
    if (char === '}' && !isInsideString) {
      curlyBracketCount--;
      word += '}';
      return;
    }
    if (char === "'") {
      isInsideString = !isInsideString;
      word += "'";
      return;
    }
    if (char === ' ') {
      word +=
        isInsideString ||
        parenthesesCount ||
        squareBracketCount ||
        curlyBracketCount
          ? ' '
          : String.fromCharCode(28);
      return;
    }
    word += char;
  });
  return word.split(String.fromCharCode(28)).filter((token) => token !== '');
};

const parseExpression = (expression) => {
  // An expression is either a value, or an expression which has to be parsed
  const trimmedExpression = expression.trim();
  if (isExpression(trimmedExpression)) {
    const tokens = getTokens(trimParentheses(trimmedExpression));
    const [operatorToken, ...argTokens] = tokens;
    return {
      tokenType: 'apply',
      operator: parseExpression(operatorToken),
      args: argTokens.map(parseExpression),
    };
  }
  if (isArray(trimmedExpression)) {
    return {
      tokenType: 'array',
      values: getTokens(trimSquareBrackets(trimmedExpression)).map(
        parseExpression
      ),
    };
  }
  if (isObject(trimmedExpression)) {
    const tokens = getTokens(trimCurlyBrackets(trimmedExpression));
    const keywords = tokens.filter((_, i) => i % 2 === 0).map(parseExpression);
    const values = tokens.filter((_, i) => i % 2 !== 0).map(parseExpression);
    if (keywords.length !== values.length) {
      throw SyntaxError(
        `There number of keys in an object must be equal to the number of values: ${trimmedExpression}`
      );
    }
    return {
      tokenType: 'object',
      keywords,
      values,
    };
  }
  // It is not an expression, so it is a list of one or more things
  const tokens = getTokens(trimmedExpression);
  if (!tokens.length) {
    throw SyntaxError(`Empty expression: ${trimmedExpression}`);
  }
  // An expression can never have more than one tokens which are not wrapped in parentheses
  if (tokens.length > 1) {
    throw SyntaxError(
      `Multiple expressions must be wrapped in parentheses: ${trimmedExpression}`
    );
  }
  const token = tokens[0];
  // TODO: If it is a word, look up the syntax tree to find the value
  if (isString(token)) {
    return {
      tokenType: 'value',
      dataType: 'string',
      value: trimSingleQuotes(token),
    };
  }
  if (isNumber(token)) {
    return {
      tokenType: 'value',
      dataType: 'number',
      value: Number(token),
    };
  }
  if (isBoolean(token)) {
    return {
      tokenType: 'value',
      dataType: 'boolean',
      value: parseBoolean(token),
    };
  }
  if (isKeyword(token)) {
    return {
      tokenType: 'keyword',
      // TODO: All keywords should have a dataType
      value: token,
    };
  }
  if (isWord(token)) {
    return {
      tokenType: 'word',
      // TODO: All words should have a dataType
      word: token,
    };
  }
};

const specialForms = {
  define: {
    tokenType: 'function',
    function: (args, scope) => {
      if (args.length !== 2) {
        throw SyntaxError(
          `${args.length} arguments passed to define. Expected 2`
        );
      }
      if (args[0].tokenType !== 'word') {
        throw SyntaxError(
          `An argument of type ${args[0].tokenType} was passed to define. Expected a word.`
        );
      }
      const value = evaluateSyntaxTree(args[1], scope);
      const word = args[0].word;
      scope[word] = value;
      return value;
    },
  },
  do: {
    tokenType: 'function',
    function: (args, scope) => {
      let value = false;
      for (let arg of args) {
        value = evaluateSyntaxTree(arg, scope);
      }
      return value;
    },
  },
  fun: {
    tokenType: 'function',
    function: (args, scope) => {
      if (!args.length) {
        throw SyntaxError(
          'No arguments were passed to fun. Expected at least a one.'
        );
      }
      const body = args.slice(-1)[0];
      const params = args.slice(0, -1).map((arg) => {
        if (arg.tokenType !== 'word') {
          throw SyntaxError(
            `Function parameters must be words, not ${param.tokenType}`
          );
        }
        return arg.word;
      });
      return {
        tokenType: 'function',
        function: (...arguments) => {
          if (arguments.length !== params.length) {
            throw TypeError(
              `${arguments.length} arguments were passed to anonymous function. Expected ${params.length}.`
            );
          }
          const localScope = Object.assign({}, scope);
          arguments.forEach((argument, i) => {
            localScope[params[i]] = argument;
          });
          return evaluateSyntaxTree(body, localScope);
        },
      };
    },
  },
  if: {
    tokenType: 'function',
    function: (args, scope) => {
      if (args.length !== 3) {
        throw SyntaxError(
          `${args.length} arguments were passed to if. Expected 3.`
        );
      }
      const condition = evaluateSyntaxTree(args[0], scope);
      if (condition.value === true) {
        return evaluateSyntaxTree(args[1], scope);
      }
      if (condition.value === false) {
        return evaluateSyntaxTree(args[2], scope);
      }
      throw TypeError(
        `The first argument of if should be a boolean (true or false). Received ${condition.value}, which is of type ${condition.type}.`
      );
    },
  },
};
const core = {
  '+': {
    tokenType: 'function',
    function: (...args) => {
      if (!args.every((arg) => arg.dataType === 'number')) {
        throw TypeError(
          `All arguments passed to + must be of type number. ${args
            .filter((arg) => arg.dataType !== 'number')
            .map((arg) => arg.value)
            .join(', ')} are not of type number.`
        );
      }
      if (args.length === 1) {
        return args[0];
      }
      return {
        tokenType: 'value',
        dataType: 'number',
        value: args.reduce((a, b) => a.value + b.value),
      };
    },
  },
  '-': {
    tokenType: 'function',
    function: (...args) => {
      // TODO: Add type validation
      if (args.length === 1) {
        return {
          tokenType: 'value',
          dataType: 'number',
          value: -args[0].value,
        };
      }
      return {
        tokenType: 'value',
        dataType: 'number',
        value: args.reduce((a, b) => a.value - b.value),
      };
    },
  },
  '*': {
    tokenType: 'function',
    function: (...args) => {
      // TODO: Add type validation
      if (args.length === 1) {
        return {
          tokenType: 'value',
          dataType: 'number',
          value: 1 / args[0].value,
        };
      }
      return {
        tokenType: 'value',
        dataType: 'number',
        value: args.reduce((a, b) => a.value * b.value),
      };
    },
  },
  '/': {
    tokenType: 'function',
    function: (...args) => {
      // TODO: Add type validation
      return {
        tokenType: 'value',
        dataType: 'number',
        value: args.reduce((a, b) => a.value / b.value),
      };
    },
  },
  '>': {
    tokenType: 'function',
    function: (...args) => {
      // TODO: Add type validation
      return {
        tokenType: 'value',
        dataType: 'number',
        value: args.every((arg, i) => i === 0 || args[i - 1].value > arg.value),
      };
    },
  },
  '<': {
    tokenType: 'function',
    function: (...args) => {
      // TODO: Add type validation
      return {
        tokenType: 'value',
        dataType: 'number',
        value: args.every((arg, i) => i === 0 || args[i - 1].value < arg.value),
      };
    },
  },
  '=': {
    tokenType: 'function',
    function: (...args) => {
      // TODO: Add type validation
      return {
        tokenType: 'value',
        dataType: 'number',
        value: args.every((arg, i) => arg.value === args[0].value),
      };
    },
  },
  '|>': {
    tokenType: 'function',
    function: (...args) => {
      const startValue = args[0];
      return args
        .slice(1)
        .reduce((aggregator, fn) => fn.function(aggregator), startValue);
    },
  },
  abs: {
    tokenType: 'function',
    function: (arg) => {
      return {
        tokenType: 'value',
        dataType: 'number',
        value: Math.abs(arg.value),
      };
    },
  },
  concat: {
    tokenType: 'function',
    function: (...args) => {
      if (args.length === 1) {
        return args[0];
      }
      return {
        tokenType: 'array',
        values: args[0].values.concat(...args.map(({ values }) => values)),
      };
    },
  },
  'even?': {
    tokenType: 'function',
    function: (number) => {
      // TODO: Add type validation
      return {
        tokenType: 'value',
        dataType: 'number',
        value: number.value % 2 === 0,
      };
    },
  },
  keys: {
    tokenType: 'function',
    function: (arg) => {
      if (arg.tokenType === 'object') {
        return {
          tokenType: 'array',
          values: arg.keywords,
        };
      }
      if (arg.tokenType === 'array') {
        // Here I don't use arg because I want to return the indices as numbers
        // because get is very strict and requires that arrays are accessed by
        // an index which is a number.
        return {
          tokenType: 'array',
          values: arg.values.map((_, i) => ({
            tokenType: 'value',
            dataType: 'number',
            value: i,
          })),
        };
      }
    },
  },
  length: {
    tokenType: 'function',
    function: (array) => {
      return {
        tokenType: 'value',
        dataType: 'number',
        value: array.values.length,
      };
    },
  },
  'odd?': {
    tokenType: 'function',
    function: (number) => {
      // TODO: Add type validation
      return {
        tokenType: 'value',
        dataType: 'number',
        value: number.value % 2 !== 0,
      };
    },
  },
  'to-string': {
    tokenType: 'function',
    function: (token) => {
      // TODO: Stringify functions
      if (token.dataType === 'string') return token.value;
      if (token.dataType === 'number') return `${token.value}`;
      if (token.tokenType === 'keyword') return token.value;
      if (token.tokenType === 'array')
        return `[ ${token.values.map(core['to-string'].function).join(' ')} ]`;
      if (token.tokenType === 'object')
        return `{ ${token.keywords
          .map(
            (keyword, i) =>
              `${core['to-string'].function(keyword)} ${core[
                'to-string'
              ].function(token.values[i])}`
          )
          .join(' ')} }`;
    },
  },
  str: {
    tokenType: 'function',
    function: (...args) => {
      return {
        tokenType: 'value',
        dataType: 'string',
        value: args.map(core['to-string'].function).join(''),
      };
    },
  },
  keyword: {
    tokenType: 'function',
    function: (key) => {
      if (key.tokenType === 'keyword') {
        return key;
      }
      if (key.tokenType === 'value') {
        return {
          tokenType: 'keyword',
          value: `:${key.value}`,
        };
      }
      throw TypeError(
        `The keyword function is only applicable for keywords, numbers and strings.Keyword was called with ${core[
          'to-string'
        ].function(key)}`
      );
    },
  },
  entries: {
    tokenType: 'function',
    function: (arg) => {
      if (arg.tokenType === 'object') {
        return {
          tokenType: 'array',
          values: arg.keywords.map((keyword, i) => ({
            tokenType: 'array',
            values: [keyword, arg.values[i]],
          })),
        };
      }
      if (arg.tokenType === 'array') {
        // Here I don't use arg because I want to return the indices as numbers
        // because get is very strict and requires that arrays are accessed by
        // an index which is a number.
        return {
          tokenType: 'array',
          values: arg.values.map((value, i) => ({
            tokenType: 'array',
            values: [
              { tokenType: 'value', dataType: 'number', value: i },
              value,
            ],
          })),
        };
      }
    },
  },
  'from-entries': {
    tokenType: 'function',
    function: (entries) => {
      return {
        tokenType: 'object',
        keywords: entries.values.map((entry) =>
          core.keyword.function(entry.values[0])
        ),
        values: entries.values.map((entry) => entry.values[1]),
        keywordToToken: Object.fromEntries(
          entries.values.map((entry) => [
            entry.values[0].value,
            entry.values[1].value,
          ])
        ),
      };
    },
  },
  get: {
    tokenType: 'function',
    function: (...args) => {
      if (args[0].tokenType === 'object') {
        if (args[1].tokenType !== 'keyword') {
          throw TypeError(
            `When accessing a value in an object, the second argument passed to get must be a keyword. ${args[1].value} is not a keyword.`
          );
        }
        return args[0].keywordToToken[args[1].value];
      }
      if (args[0].tokenType === 'array') {
        if (args[1].dataType !== 'number') {
          throw TypeError(
            `When accessing a value in an array, the second argument passed to get must be a number. ${args[1].value} is not a number.`
          );
        }
        return args[0].values[args[1].value];
      }
      throw TypeError(
        `Get can only be used to access values on objects or arrays. Tried to access value on ${core[
          'to-string'
        ].function(args[0])} (${args[0].tokenType})`
      );
    },
  },
  map: {
    tokenType: 'function',
    function: (fn, array) => {
      return {
        tokenType: 'array',
        values: array.values.map((item) => fn.function(item)),
      };
    },
  },
  filter: {
    tokenType: 'function',
    function: (fn, array) => {
      return {
        tokenType: 'array',
        values: array.values.filter((item) => fn.function(item)),
      };
    },
  },
  max: {
    tokenType: 'function',
    function: (...args) => {
      // TODO: Add type validation
      return {
        tokenType: 'value',
        dataType: 'number',
        value: Math.max(...args.map(({ value }) => value)),
      };
    },
  },
  // | (fn, array) => any
  // | (fn, initialValue, array) => any
  // ( initialValue is the middle argument to always have data as last argument
  //   to facilitate currying with partial)
  reduce: {
    tokenType: 'function',
    function: (...args) => {
      if (args.length === 2) {
        const fn = args[0];
        const array = args[1];
        return array.values.reduce((accumulator, item) =>
          fn.function(accumulator, item)
        );
      }
      if (args.length === 3) {
        const fn = args[0];
        const initialValue = args[1];
        const array = args[2];
        return array.values.reduce(
          (accumulator, item) => fn.function(accumulator, item),
          initialValue
        );
      }
      throw SyntaxError(
        `${args.length} arguments were passed to reduce. Expected 2 or 3.`
      );
    },
  },
  slice: {
    tokenType: 'function',
    function: (...args) => {
      if (args.length === 1) {
        const array = args[0].values;
        return {
          tokenType: 'array',
          values: array.slice(),
        };
      }
      if (args.length === 2) {
        const start = args[0].value;
        const array = args[1].values;
        return {
          tokenType: 'array',
          values: array.slice(start),
        };
      }
      if (args.length === 3) {
        const start = args[0].value;
        const end = args[1].value;
        const array = args[2].values;
        return {
          tokenType: 'array',
          values: array.slice(start, end),
        };
      }
      throw SyntaxError(
        `${args.length} arguments were passed to slice. Expected 1, 2 or 3.`
      );
    },
  },
  print: {
    tokenType: 'function',
    function: (...args) => {
      if (args.length !== 1) {
        throw SyntaxError(
          `${args.length} arguments were passed to if. Expected 1.`
        );
      }
      // Don't remove this console log. It's intended to be here
      console.log(core['to-string'].function(args[0]));
      return args[0];
    },
  },
  values: {
    tokenType: 'function',
    function: (arg) => {
      if (arg.tokenType === 'object') {
        return {
          tokenType: 'array',
          values: arg.values,
        };
      }
      throw TypeError(
        `The values function is only applicable to objects. ${core[
          'to-string'
        ].function(
          arg
        )} is not a object. It does not make sense to apply it to an array, for instance, as that would just return an identical array.`
      );
    },
  },
};
const evaluateSyntaxTree = (syntaxTree, scope) => {
  if (syntaxTree.tokenType === 'value') {
    return syntaxTree;
  }
  if (syntaxTree.tokenType === 'keyword') {
    return syntaxTree;
  }
  if (syntaxTree.tokenType === 'array') {
    return {
      tokenType: 'array',
      values: syntaxTree.values.map((arg) => evaluateSyntaxTree(arg, scope)),
    };
  }
  if (syntaxTree.tokenType === 'object') {
    const keywords = syntaxTree.keywords.map((keywordSyntaxTree) =>
      evaluateSyntaxTree(keywordSyntaxTree, scope)
    );
    const malformedKeywords = keywords.filter(
      (keyword) => keyword.tokenType !== 'keyword'
    );
    if (malformedKeywords.length) {
      throw SyntaxError(
        `Malformed keywords: ${malformedKeywords
          .map((keyword) => keyword.value)
          .join(', ')} are not valid keywords.`
      );
    }
    const values = syntaxTree.values.map((valueSyntaxTree) =>
      evaluateSyntaxTree(valueSyntaxTree, scope)
    );
    return {
      tokenType: 'object',
      keywordToToken: Object.fromEntries(
        keywords.map((keyword, i) => [keyword.value, values[i]])
      ),
      keywords,
      values,
    };
  }
  if (syntaxTree.tokenType === 'word') {
    if (scope.hasOwnProperty(syntaxTree.word)) {
      return scope[syntaxTree.word];
    }
    throw ReferenceError(`${syntaxTree.word} is not defined.`);
  }
  if (syntaxTree.tokenType === 'apply') {
    const { operator, args } = syntaxTree;
    if (
      operator.tokenType === 'word' &&
      specialForms.hasOwnProperty(operator.word)
    ) {
      return specialForms[operator.word].function(args, scope);
    }
    const evaluatedOperator = evaluateSyntaxTree(operator, scope);
    if (evaluatedOperator.tokenType === 'function') {
      return evaluatedOperator.function(
        ...args.map((arg) => evaluateSyntaxTree(arg, scope))
      );
    }
    throw TypeError('Cannot apply a non-function.');
  }
};

const convertFromJavaScriptValue = (javaScriptValue) => {
  if (javaScriptValue === null || javaScriptValue === undefined) {
    return {
      tokenType: 'value',
      dataType: 'number',
      value: 0,
    };
  }
  if (typeof javaScriptValue === 'string') {
    return {
      tokenType: 'value',
      dataType: 'string',
      value: javaScriptValue,
    };
  }
  if (typeof javaScriptValue === 'number') {
    return {
      tokenType: 'value',
      dataType: 'number',
      value: javaScriptValue,
    };
  }
  if (typeof javaScriptValue === 'boolean') {
    return {
      tokenType: 'value',
      dataType: 'boolean',
      value: javaScriptValue,
    };
  }
  if (typeof javaScriptValue === 'object' && Array.isArray(javaScriptValue)) {
    return {
      tokenType: 'array',
      values: javaScriptValue.map(convertFromJavaScriptValue),
    };
  }
  if (typeof javaScriptValue === 'object') {
    const keywords = Object.keys(javaScriptValue).map((key) => ({
      tokenType: 'keyword',
      value: `:${key}`,
    }));
    const values = Object.values(javaScriptValue).map(
      convertFromJavaScriptValue
    );
    return {
      tokenType: 'object',
      keywords,
      keywordToToken: Object.fromEntries(
        keywords.map((keyword, i) => [keyword.value, values[i]])
      ),
      values,
    };
  }
  throw TypeError(
    `Only data of type string, number, boolean, array or object can be converted from JavaScript. ${javaScriptValue} is of type ${typeof javaScriptValue}.`
  );
};

const callWithJavaScriptArguments = (codeString, ...javaScriptArguments) => {
  return convertToJavaScriptValue(
    evaluateSyntaxTree(
      {
        tokenType: 'apply',
        operator: parseExpression(codeString),
        args: javaScriptArguments
          .filter((arg) => arg !== null && arg !== undefined)
          .map(convertFromJavaScriptValue),
      },
      core
    )
  );
};

const convertToJavaScriptValue = (syntaxTree) => {
  if (syntaxTree.tokenType === 'value') {
    return syntaxTree.value;
  }
  if (syntaxTree.tokenType === 'array') {
    return syntaxTree.values.map((arg) => convertToJavaScriptValue(arg));
  }
  if (syntaxTree.tokenType === 'object') {
    const { keywords, values } = syntaxTree;
    const entries = keywords.map((keyword, i) => {
      const valueSyntaxTree = values[i];
      const value = convertToJavaScriptValue(valueSyntaxTree);
      return [removeColonFromKeyword(keyword.value), value];
    });
    return Object.fromEntries(entries);
  }
  if (syntaxTree.tokenType === 'keyword') {
    return syntaxTree.value;
  }
};

const evaluate = (expression) =>
  convertToJavaScriptValue(
    evaluateSyntaxTree(parseExpression(expression), { ...core }) // I need to destructure core so that modifications to the scope here do not persist when using it in a new evaluation
  );

module.exports = { callWithJavaScriptArguments };

  return module.exports;
})();

modules['src/model/Model.js'] = (() => {
  const module = { exports: {} };
  const {
  getExportedProject,
  getAllProjects,
  createProject,
  updateProjectById,
  deleteProjectById,
} = include('src/data/Data.js');

const LanguageParser = include(
  'src/libraries/languageParser/LanguageParser.js'
);

const evaluateCode = (apiResponse, widgetsCode) => {
  let parsedApiResponse;
  try {
    parsedApiResponse = JSON.parse(apiResponse);
  } catch (e) {
    parsedApiResponse = null;
  }
  const evaluatedCodeCalledWithApiResponse = LanguageParser.callWithJavaScriptArguments(
    widgetsCode,
    parsedApiResponse
  );
  return evaluatedCodeCalledWithApiResponse;
};

const Model = ({ router, isExported, state, setState }) => {
  const dataModel = { projects: [] };
  const viewModel = {};

  viewModel.loadAllProjects = () => {
    dataModel.projects = state.isExported
      ? getExportedProject()
      : getAllProjects();
    setState({
      projects: dataModel.projects.map(
        ({ id, name, apiRequests, derivedValuesCode, widgetsCode }, index) => ({
          id,
          name,
          nameInputValue: name,
        })
      ),
    });
    if (state.isExported) {
      setState({ selectedProjectId: dataModel.projects[0].id });
    }

    const selectedProject = dataModel.projects.find(
      ({ id }) => id === state.selectedProjectId
    );
    if (!selectedProject) {
      setState({
        selectedProjectId: null,
        selectedProjectName: null,
        selectedApiUrl: '',
        selectedApiInterval: null,
        selectedWidgetsCode: '',
      });
      return;
    }
    setState({
      selectedProjectName: selectedProject.name,
      selectedApiUrl: selectedProject.apiUrl,
      selectedApiInterval: selectedProject.apiInterval,
      selectedWidgetsCode: selectedProject.widgetsCode,
    });
  };
  viewModel.loadAllProjects();

  viewModel.createNewProject = () => {
    createProject({
      name: 'Untitled project',
      apiUrl: '',
      apiInterval: 0,
      widgetsCode: '',
    });
    viewModel.loadAllProjects();
  };

  viewModel.setProjectNameInputValue = (projectId, inputValue) => {
    setState({
      projects: state.projects.map((project) => {
        if (project.id === projectId) {
          return { ...project, nameInputValue: inputValue };
        }
        return project;
      }),
    });
  };

  viewModel.editProjectName = (projectId) => {
    setState({
      projects: state.projects.map((project) => {
        if (project.id === projectId) {
          return { ...project, isEditing: true };
        }
        return project;
      }),
    });
  };

  viewModel.cancelEditingProjectName = (projectId) => {
    setState({
      projects: state.projects.map((project) => {
        if (project.id === projectId) {
          return { ...project, nameInputValue: project.name, isEditing: false };
        }
        return project;
      }),
    });
  };

  viewModel.saveProjectName = (projectId) => {
    const project = state.projects.find(({ id }) => id === projectId);
    updateProjectById(projectId, {
      name: project.nameInputValue,
    });
    viewModel.loadAllProjects();
  };

  viewModel.saveSelectedProject = () => {
    updateProjectById(state.selectedProjectId, {
      name: state.selectedName,
      apiUrl: state.selectedApiUrl,
      apiInterval: state.selectedApiInterval,
      derivedValuesCode: state.selectedDerivedValuesCode,
      widgetsCode: state.selectedWidgetsCode,
    });
    viewModel.loadAllProjects();
  };

  viewModel.deleteProject = (projectId) => {
    deleteProjectById(projectId);
    viewModel.loadAllProjects();
  };

  viewModel.updateApiUrl = (projectId, apiUrl) => {
    updateProjectById(projectId, { apiUrl });
    viewModel.loadAllProjects();
    setTimeout(() => {
      fetchDataFromApi();
      repeatedlyFetchDataFromApi(state.selectedApiInterval);
    }, 1000);
  };

  viewModel.updateApiInterval = (projectId, apiInterval) => {
    updateProjectById(projectId, { apiInterval });
    viewModel.loadAllProjects();
    setTimeout(() => {
      fetchDataFromApi();
      repeatedlyFetchDataFromApi(state.selectedApiInterval);
    }, 1000);
  };

  viewModel.updateWidgetsCode = (projectId, widgetsCode) => {
    updateProjectById(projectId, { widgetsCode });
    viewModel.loadAllProjects();
    updateValues();
  };

  viewModel.testApiUrlInput = () => {
    fetch(state.selectedApiUrl)
      .then((response) => response.json())
      .then((jsonResponse) => {
        setState({
          selectedApiUrlTestPreview: JSON.stringify(jsonResponse, null, 2),
        });
      });
  };

  const evaluatedCodeIsValid = (evaluatedCode) => {
    return evaluatedCode.every((widget) => typeof widget === 'object');
  };

  const updateValues = () => {
    let evaluatedCode;
    try {
      evaluatedCode = evaluateCode(
        state.apiResponse,
        state.selectedWidgetsCode
      );
    } catch (e) {
      console.warn('Failed to evaluate code: ', e);
      evaluatedCode = [];
    }
    if (evaluatedCodeIsValid(evaluatedCode)) {
      setState({
        widgets: evaluatedCode,
      });
    }
  };

  const fetchDataFromApi = () => {
    fetch(state.selectedApiUrl)
      .then((response) => response.json())
      .then((jsonResponse) => {
        setState({
          apiResponse: JSON.stringify(jsonResponse, null, 2),
        });
        updateValues();
      });
  };

  const repeatedlyFetchDataFromApi = (timeoutInSeconds) =>
    setTimeout(() => {
      console.log('repeatedly fetch data from api');
      if (state.selectedApiInterval !== 0) {
        fetchDataFromApi();
      }
      if (timeoutInSeconds === state.selectedApiInterval) {
        repeatedlyFetchDataFromApi(timeoutInSeconds);
      }
    }, timeoutInSeconds * 1000);
  repeatedlyFetchDataFromApi();

  const syncSelectedProjectWithRouter = ({ params, currentRoute }) => {
    if (currentRoute.indexOf('/projects/<projectId:string>') === 0) {
      const selectedProject = dataModel.projects.find(
        ({ id }) => id === params.projectId
      );
      setState({
        currentRoute,
        params,
        selectedProjectId: selectedProject.id,
        selectedProjectName: selectedProject.name,
        selectedApiUrl: selectedProject.apiUrl,
        selectedApiInterval: selectedProject.apiInterval,
        selectedWidgetsCode: selectedProject.widgetsCode,
      });
      if (currentRoute === '/projects/<projectId:string>/data-sources') {
        setState({
          currentRoute,
          params,
          lastVisitedProjectView: 'data-sources',
        });
      }
      if (
        currentRoute.indexOf(
          '/projects/<projectId:string>/dashboard-editor'
        ) === 0
      ) {
        setState({
          currentRoute,
          params,
          lastVisitedProjectView: 'dashboard-editor',
        });
      }
      if (currentRoute === '/projects/<projectId:string>/dashboard') {
        setState({
          currentRoute,
          params,
          lastVisitedProjectView: 'dashboard',
        });
      }
    } else {
      setState({ currentRoute, params });
    }
  };
  syncSelectedProjectWithRouter(router);
  router.onHashChange(syncSelectedProjectWithRouter);

  return viewModel;
};

module.exports = Model;

  return module.exports;
})();

modules['src/views/projects/newProject/NewProject.js'] = (() => {
  const module = { exports: {} };
  const { compose } = include('src/libraries/simpleHTML/SimpleHTML.js');

// getProps::() => { viewModel }
const NewProject = (getProps) => {
  let color = 'slategray';
  const element = compose(
    'span',
    () => ({
      innerText: 'New project',
      onmouseenter: () => {
        color = 'darkslategray';
        element.update();
      },
      onmouseleave: () => {
        color = 'slategray';
        element.update();
      },
      onclick: getProps().viewModel.createNewProject,
      style: `color: ${color};
              cursor: pointer;
              margin: 32px;
              padding: 0 16px;
              height: 64px;
              background: none;
              line-height: 64px;
              font-size: 16px;
              display: inline-block;`,
    }),
    []
  );
  return element;
};

module.exports = NewProject;

  return module.exports;
})();

modules['src/components/codeEditor/CodeEditor.js'] = (() => {
  const module = { exports: {} };
  const { compose } = include('src/libraries/simpleHTML/SimpleHTML.js');

const CodeEditor = (getProps) => {
  const element = compose('div', { style: 'padding: 10px;' }, [
    compose(
      'textarea',
      () => ({
        oninput: getProps().oninput,
        style: `height: 600px;
                border-radius: 5px;
                font-family: "Courier New", Courier, monospace;
                background: rgba(0, 0, 0, 0.05);
                outline: none;
                font-size: 15px;
                padding: 10px;
                border: none;
                resize: none;
                width: 100%;
                box-shadow: inset rgba(0, 0, 0, 0.5) 0 0 10px -5px;`,
        value: getProps().value,
      }),
      []
    ),
  ]);

  return element;
};

module.exports = CodeEditor;

  return module.exports;
})();

modules['src/components/horizontalNavigator/HorizontalNavigator.js'] = (() => {
  const module = { exports: {} };
  const { compose } = include('src/libraries/simpleHTML/SimpleHTML.js');

const HorizontalNavigator = (_, children) => {
  const element = compose(
    'div',
    {
      style: `height: 60px;
              box-shadow: rgba(0, 0, 0, 0.25) 0 0 10px -5px;
              background: white;
              color: darkslategray;`,
    },
    children
  );
  return element;
};

module.exports = HorizontalNavigator;

  return module.exports;
})();

modules['src/app/titleBar/atoms.js'] = (() => {
  const module = { exports: {} };
  const { compose } = include('src/libraries/simpleHTML/SimpleHTML.js');

const ViewTitle = (_, children) => {
  const element = compose(
    'div',
    {
      style: `font-size: 25px;
              padding: 0 10px;
              line-height: 60px;
              display: inline-block;`,
    },
    children
  );
  return element;
};

const ExportButton = (getProps) => {
  const element = compose(
    'div',
    () => ({
      innerText: getProps().innerText,
      onclick: getProps().onclick,
      style: `font-size: 16px;
              padding: 0 16px;
              float: right;
              line-height: 64px;
              cursor: pointer;`,
    }),
    []
  );

  return element;
};

module.exports = { ViewTitle, ExportButton };

  return module.exports;
})();

modules['src/app/titleBar/exportedTitleBar/ExportedTitleBar.js'] = (() => {
  const module = { exports: {} };
  const HorizontalNavigator = include(
  'src/components/horizontalNavigator/HorizontalNavigator.js'
);
const { ViewTitle } = include('src/app/titleBar/atoms.js');

const { compose } = include('src/libraries/simpleHTML/SimpleHTML.js');

const ExportedTitleBar = (getProps) => {
  const element = HorizontalNavigator(() => ({}), [
    ViewTitle(() => ({}), [
      compose(
        'span',
        () => ({
          innerText: getProps().state.selectedProjectName,
          style: `color: darkslategray;
                        cursor: pointer;`,
          onclick: () => {
            location.hash = '#!/';
          },
        }),
        []
      ),
    ]),
  ]);
  return element;
};

module.exports = ExportedTitleBar;

  return module.exports;
})();

modules['src/app/titleBar/unexportedTitleBar/UnexportedTitleBar.js'] = (() => {
  const module = { exports: {} };
  const HorizontalNavigator = include(
  'src/components/horizontalNavigator/HorizontalNavigator.js'
);
const { ViewTitle, ExportButton } = include('src/app/titleBar/atoms.js');
const { compose, If } = include('src/libraries/simpleHTML/SimpleHTML.js');

const UnexportedTitleBar = (getProps) => {
  const getCurrentRoute = () => getProps().state.currentRoute;
  const getSelectedProjectId = () => getProps().state.selectedProjectId;
  const getLastVisitedProjectView = () =>
    getProps().state.lastVisitedProjectView;
  const element = HorizontalNavigator(() => ({}), [
    ViewTitle(() => ({}), [
      compose(
        'span',
        {
          innerText: 'Projects',
          onclick: () => (location.hash = '#!/projects'),
          style: 'cursor: pointer;',
        },
        []
      ),
      compose(
        'span',
        () => ({
          innerText: getProps().state.selectedProjectName
            ? ` / ${getProps().state.selectedProjectName}`
            : '',
          style: `color: ${
            getCurrentRoute().indexOf('/projects/<projectId:string>') === 0
              ? 'darkslategray'
              : 'lightgray'
          };
                  cursor: pointer;`,
          onclick: () => {
            location.hash = `#!/projects/${getSelectedProjectId()}/${
              getLastVisitedProjectView() || ''
            }`;
          },
        }),
        []
      ),
    ]),
    If(
      () => getProps().state.selectedProjectId,
      () => [
        ExportButton(
          () => ({
            innerText: 'Export',
            onclick: () => {
              const { state } = getProps();
              const element = document.createElement('a');
              // SInce just the first occurrence of the code will be replaced, we need to make sure that this code does not replace itself, so we construct the match on call time
              const fileContent = document.head.innerHTML
                .replace(
                  '*c*o*n*s*t* *i*s*E*x*p*o*r*t*e*d* *=* *f*a*l*s*e*;*'
                    .split('*')
                    .join(''),
                  '*c*o*n*s*t* *i*s*E*x*p*o*r*t*e*d* *=* *t*r*u*e*;*'
                    .split('*')
                    .join('')
                )
                .replace(
                  '*c*o*n*s*t* *g*e*t*E*x*p*o*r*t*e*d*P*r*o*j*e*c*t* *=* *(*)* *=*>* *[*]*;*'
                    .split('*')
                    .join(''),
                  `*c*o*n*s*t* *g*e*t*E*x*p*o*r*t*e*d*P*r*o*j*e*c*t* *=* *(*)* *=*>*`
                    .split('*')
                    .join('') +
                    JSON.stringify([
                      {
                        id: state.selectedProjectId,
                        name: state.selectedProjectName,
                        apiUrl: state.selectedApiUrl,
                        apiInterval: state.selectedApiInterval,
                        derivedValuesCode: state.selectedDerivedValuesCode,
                        widgetsCode: state.selectedWidgetsCode,
                      },
                    ])
                );
              const file = new Blob([fileContent], { type: 'text/plain' });
              element.href = URL.createObjectURL(file);
              element.download = `${state.selectedProjectName
                .toLowerCase()
                .split(' ')
                .join('-')}.html`;
              document.body.appendChild(element); // Required for this to work in FireFox
              element.click();
            },
          }),
          []
        ),
      ]
    ),
  ]);
  return element;
};

module.exports = UnexportedTitleBar;

  return module.exports;
})();

modules['src/app/titleBar/TitleBar.js'] = (() => {
  const module = { exports: {} };
  const ExportedTitleBar = include(
  'src/app/titleBar/exportedTitleBar/ExportedTitleBar.js'
);
const UnexportedTitleBar = include(
  'src/app/titleBar/unexportedTitleBar/UnexportedTitleBar.js'
);

const TitleBar = (getProps) => {
  const element = getProps().state.isExported
    ? ExportedTitleBar(getProps)
    : UnexportedTitleBar(getProps);

  return element;
};

module.exports = TitleBar;

  return module.exports;
})();

modules['src/views/projects/projectPreviewContainer/ProjectPreviewContainer.js'] = (() => {
  const module = { exports: {} };
  const { compose } = include('src/libraries/simpleHTML/SimpleHTML.js');

const ProjectPreviewContainer = (_, children) => {
  const element = compose(
    'div',
    {
      style: `color: dimgray;
              margin: 32px 32px 0 32px;
              height: 64px;
              background: white;
              line-height: 64px;
              font-size: 16px;
              cursor: pointer;
              box-shadow: rgba(0, 0, 0, 0.25) 0 0 10px -5px;`,
    },
    children
  );
  return element;
};

module.exports = ProjectPreviewContainer;

  return module.exports;
})();

modules['src/views/projects/projectPreviewButton/ProjectPreviewButton.js'] = (() => {
  const module = { exports: {} };
  const { compose } = include('src/libraries/simpleHTML/SimpleHTML.js');

// getProps::() => value
const ProjectPreviewButton = (getProps) => {
  let isHovered = false;
  const element = compose(
    'button',
    () => ({
      onclick: getProps().onclick,
      onmouseenter: () => {
        isHovered = true;
        element.update();
      },
      onmouseleave: () => {
        isHovered = false;
        element.update();
      },
      innerText: getProps().innerText,
      style: `color: ${isHovered ? 'darkslategray' : 'slategray'};
              height: 64px;
              background: white;
              line-height: 64px;
              font-size: 16px;
              width: 64px;
              text-align: center;
              border: none;
              outline: none;
              cursor: pointer;`,
    }),
    []
  );
  return element;
};

module.exports = ProjectPreviewButton;

  return module.exports;
})();

modules['src/views/projects/projectPreview/ProjectPreview.js'] = (() => {
  const module = { exports: {} };
  const ProjectPreviewContainer = include(
  'src/views/projects/projectPreviewContainer/ProjectPreviewContainer.js'
);
const ProjectPreviewButton = include(
  'src/views/projects/projectPreviewButton/ProjectPreviewButton.js'
);
const { compose } = include('src/libraries/simpleHTML/SimpleHTML.js');

// getProps::() => { state, viewModel, name, id }
const ProjectPreview = (getProps) => {
  const getId = () => getProps().id;
  const getViewModel = () => getProps().viewModel;
  const element = ProjectPreviewContainer(() => ({}), [
    compose(
      'div',
      () => {
        const { id, state, name } = getProps();
        return {
          onclick: () => {
            location.hash = `#!/projects/${id}/${
              state.lastVisitedProjectView || ''
            }`;
          },
          style: `padding: 0 16px;
                  width: calc(100% - 128px);
                  box-sizing: border-box;
                  display: inline-block;`,
          innerText: name,
        };
      },
      []
    ),
    ProjectPreviewButton(
      () => ({
        innerText: 'Delete',
        onclick: () => getViewModel().deleteProject(getId()),
      }),
      []
    ),
    ProjectPreviewButton(
      () => ({
        innerText: 'Edit',
        onclick: () => getViewModel().editProjectName(getId()),
      }),
      []
    ),
  ]);

  return element;
};

module.exports = ProjectPreview;

  return module.exports;
})();

modules['src/views/projects/projectNameInputContainer/ProjectNameInputContainer.js'] = (() => {
  const module = { exports: {} };
  const { compose } = include('src/libraries/simpleHTML/SimpleHTML.js');

const ProjectNameInputContainer = (getProps) => {
  const element = compose(
    'input',
    () => {
      const { value, oninput } = getProps();
      return {
        // TODO: Make this one align nicely next to the input
        value,
        oninput,
        style: `color: dimgray;
              height: 64px;
              padding: 8px;
              line-height: 64px;
              font-size: 16px;
              width: calc(100% - 128px);
              display: inline-block;
              box-sizing: border-box;`,
      };
    },
    []
  );
  return element;
};

module.exports = ProjectNameInputContainer;

  return module.exports;
})();

modules['src/views/projects/projectNameInput/ProjectNameInput.js'] = (() => {
  const module = { exports: {} };
  const ProjectPreviewButton = include(
  'src/views/projects/projectPreviewButton/ProjectPreviewButton.js'
);
const ProjectPreviewContainer = include(
  'src/views/projects/projectPreviewContainer/ProjectPreviewContainer.js'
);
const ProjectNameInputContainer = include(
  'src/views/projects/projectNameInputContainer/ProjectNameInputContainer.js'
);

// getProps::() => { viewModel, id, nameInputValue }
const ProjectNameInput = (getProps) => {
  const element = ProjectPreviewContainer(() => ({}), [
    ProjectNameInputContainer(
      () => ({
        value: getProps().nameInputValue,
        oninput: ({ target }) => {
          const { id, viewModel } = getProps();
          viewModel.setProjectNameInputValue(id, target.value);
        },
      }),
      []
    ),
    ProjectPreviewButton(
      () => ({
        innerText: 'Cancel',
        onclick: () => {
          const { id, viewModel } = getProps();
          viewModel.cancelEditingProjectName(id);
        },
      }),
      []
    ),
    ProjectPreviewButton(
      () => ({
        innerText: 'Save',
        onclick: () => {
          const { id, viewModel } = getProps();
          viewModel.saveProjectName(id);
        },
      }),
      []
    ),
  ]);
  return element;
};

module.exports = ProjectNameInput;

  return module.exports;
})();

modules['src/views/projects/Projects.js'] = (() => {
  const module = { exports: {} };
  const ProjectPreview = include(
  'src/views/projects/projectPreview/ProjectPreview.js'
);
const ProjectNameInput = include(
  'src/views/projects/projectNameInput/ProjectNameInput.js'
);
const NewProject = include('src/views/projects/newProject/NewProject.js');
const { compose, Each, If } = include('src/libraries/simpleHTML/SimpleHTML.js');

// getProps::() => { viewModel, state }
const Projects = (getProps) => {
  const element = compose('div', {}, [
    Each(
      () => getProps().state.projects.filter(({ isEmpty }) => !isEmpty),
      (getCurrentValue) => [
        If(
          () => getCurrentValue().isEditing,
          () => [
            ProjectNameInput(() => ({
              viewModel: getProps().viewModel,
              id: getCurrentValue().id,
              nameInputValue: getCurrentValue().nameInputValue,
            })),
          ],
          () => [
            ProjectPreview(() => ({
              state: getProps().state,
              viewModel: getProps().viewModel,
              id: getCurrentValue().id,
              name: getCurrentValue().name,
            })),
          ]
        ),
      ]
    ),
    NewProject(getProps),
  ]);
  return element;
};

module.exports = Projects;

  return module.exports;
})();

modules['src/views/dataSources/apiInputLabel/ApiInputLabel.js'] = (() => {
  const module = { exports: {} };
  const { compose } = include('src/libraries/simpleHTML/SimpleHTML.js');

const ApiInputLabel = (getProps) => {
  const element = compose(
    'span',
    () => ({
      innerText: getProps().innerText,
      // width = 8 x 20px
      // height = 2 x 20px
      style: `color: dimgray;
              height: 40px;
              padding: 10px;
              line-height: 40px;
              font-size: 15px;
              width: 160px;
              display: inline-block;`,
    }),
    []
  );
  return element;
};

module.exports = ApiInputLabel;

  return module.exports;
})();

modules['src/views/dataSources/apiIntervalInput/ApiIntervalInput.js'] = (() => {
  const module = { exports: {} };
  const ApiInputLabel = include(
  'src/views/dataSources/apiInputLabel/ApiInputLabel.js'
);
const { compose } = include('src/libraries/simpleHTML/SimpleHTML.js');

const ApiIntervalInput = (getProps) => {
  const element = compose('div', {}, [
    compose(
      'span',
      {
        style: `box-sizing: border-box;
                display: inline-block;
                padding: 10px;
                width: 160px;`,
      },
      [ApiInputLabel(() => ({ innerText: 'Fetch interval (s)' }))]
    ),
    compose(
      'span',
      {
        style: `box-sizing: border-box;
                display: inline-block;
                padding: 10px;
                width: calc(100% - 160px);`,
      },
      [
        compose(
          'input',
          () => ({
            oninput: ({ target }) => {
              const { state, viewModel } = getProps();
              viewModel.updateApiInterval(
                state.selectedProjectId,
                Number(target.value)
              );
            },
            style: `border-radius: 5px;
                    font-family: "Courier New", Courier, monospace;
                    background: rgba(0, 0, 0, 0.05);
                    outline: none;
                    font-size: 15px;
                    padding: 10px;
                    border: none;
                    width: 100%;
                    box-shadow: inset rgba(0, 0, 0, 0.5) 0 0 10px -5px;`,
            value: getProps().state.selectedApiInterval,
          }),
          []
        ),
      ]
    ),
  ]);
  return element;
};

module.exports = ApiIntervalInput;

  return module.exports;
})();

modules['src/components/textButton/TextButton.js'] = (() => {
  const module = { exports: {} };
  const { compose } = include('src/libraries/simpleHTML/SimpleHTML.js');

const TextButton = (getProps) => {
  let isHovered = false;

  const element = compose(
    'button',
    () => ({
      innerText: getProps().innerText,
      onclick: getProps().onclick,
      onmouseenter: () => {
        isHovered = true;
        element.update();
      },
      onmouseleave: () => {
        isHovered = false;
        element.update();
      },
      style: `color: ${isHovered ? 'darkslategray' : 'slategray'};
              background: none;
              height: 40px;
              line-height: 40px;
              font-size: 15px;
              width: 100%;
              text-align: left;
              border: none;
              outline: none;
              cursor: pointer;`,
    }),
    []
  );
  return element;
};

module.exports = TextButton;

  return module.exports;
})();

modules['src/views/dataSources/apiUrlTestPreview/ApiUrlTestPreview.js'] = (() => {
  const module = { exports: {} };
  const { compose } = include('src/libraries/simpleHTML/SimpleHTML.js');

const ApiUrlTestPreview = (getProps) => {
  const element = compose(
    'div',
    () => ({
      innerText: getProps().innerText,
      style: `box-shadow: inset rgba(0, 0, 0, 0.5) 0 0 10px -5px;
              font-family: "Courier New", Courier, monospace;
              background: rgba(0, 0, 0, 0.05);
              box-sizing: border-box;
              color: lightslategray;
              display: inline-block;
              white-space: pre-wrap;
              border-radius: 5px;
              line-height: 40px;
              max-height: 300px;
              min-height: 40px;
              font-size: 15px;
              overflow: auto;
              outline: none;
              padding: 10px;
              border: none;
              resize: none;
              width: 100%;`,
    }),
    []
  );

  return element;
};

module.exports = ApiUrlTestPreview;

  return module.exports;
})();

modules['src/views/dataSources/apiUrlInput/ApiUrlInput.js'] = (() => {
  const module = { exports: {} };
  const ApiInputLabel = include(
  'src/views/dataSources/apiInputLabel/ApiInputLabel.js'
);
const TextButton = include('src/components/textButton/TextButton.js');
const ApiUrlTestPreview = include(
  'src/views/dataSources/apiUrlTestPreview/ApiUrlTestPreview.js'
);
const { compose } = include('src/libraries/simpleHTML/SimpleHTML.js');

const ApiUrlInput = (getProps) => {
  const { viewModel } = getProps();
  const element = compose('div', {}, [
    // The row where you can enter the API URL
    compose('div', {}, [
      compose(
        'span',
        {
          style: `box-sizing: border-box;
                  display: inline-block;
                  padding: 10px;
                  width: 160px;`,
        },
        [ApiInputLabel(() => ({ innerText: 'API URL' }))]
      ),
      compose(
        'span',
        {
          style: `box-sizing: border-box;
                  display: inline-block;
                  padding: 10px;
                  width: calc(100% - 160px);`,
        },
        [
          compose(
            'input',
            () => ({
              oninput: ({ target }) => {
                viewModel.updateApiUrl(
                  getProps().state.selectedProjectId,
                  target.value
                );
              },
              style: `border-radius: 5px;
                      font-family: "Courier New", Courier, monospace;
                      background: rgba(0, 0, 0, 0.05);
                      outline: none;
                      font-size: 15px;
                      padding: 10px;
                      border: none;
                      width: 100%;
                      box-shadow: inset rgba(0, 0, 0, 0.5) 0 0 10px -5px;`,
              value: getProps().state.selectedApiUrl,
            }),
            []
          ),
        ]
      ),
    ]),
    // The row where you can test the API URL
    compose('div', {}, [
      compose(
        'span',
        {
          // float: left makes sure the label stays at the top of the parent div
          // when the preview box next to it expands.
          style: `box-sizing: border-box;
                  display: inline-block;
                  float: left;
                  padding: 10px;
                  width: 160px;`,
        },
        [
          TextButton(() => ({
            innerText: 'Test API URL',
            onclick: getProps().viewModel.testApiUrlInput,
          })),
        ]
      ),
      compose(
        'span',
        {
          style: `box-sizing: border-box;
                  display: inline-block;
                  padding: 10px;
                  width: calc(100% - 160px);`,
        },
        [
          ApiUrlTestPreview(
            () => ({ innerText: getProps().state.selectedApiUrlTestPreview }),
            []
          ),
        ]
      ),
    ]),
  ]);
  return element;
};

module.exports = ApiUrlInput;

  return module.exports;
})();

modules['src/views/dataSources/DataSources.js'] = (() => {
  const module = { exports: {} };
  const ApiIntervalInput = include(
  'src/views/dataSources/apiIntervalInput/ApiIntervalInput.js'
);
const { compose } = include('src/libraries/simpleHTML/SimpleHTML.js');
const ApiUrlInput = include('src/views/dataSources/apiUrlInput/ApiUrlInput.js');

const DataSources = (getProps) => {
  const element = compose('div', {}, [
    ApiUrlInput(getProps),
    ApiIntervalInput(getProps),
  ]);
  return element;
};

module.exports = DataSources;

  return module.exports;
})();

modules['src/libraries/simpleUI/Constants.js'] = (() => {
  const module = { exports: {} };
  const Colors = {
  TextColor: 'slategray',
  HighlightedTextColor: 'darkslategray',
  DisabledTextColor: 'lightgray',
  HighlightColor: 'deepskyblue',
};

const Sizes = {
  FontSize: 15,
  Padding: 10,
  Unit: 20,
};

module.exports = {
  Colors,
  Sizes,
};

  return module.exports;
})();

modules['src/libraries/simpleUI/NavigationButton.js'] = (() => {
  const module = { exports: {} };
  const { Colors } = include('src/libraries/simpleUI/Constants.js');
const { compose } = include('src/libraries/simpleHTML/SimpleHTML.js');

const getColor = (isHovered, isSelected) => {
  return isSelected || isHovered
    ? Colors.HighlightedTextColor
    : Colors.TextColor;
};

const getBorderBottom = (isSelected) => {
  return isSelected ? `2px solid ${Colors.HighlightColor}` : 'none';
};

const NavigationButton = (getProps) => {
  let isHovered = false;

  const getIsSelected = () => getProps().isSelected;
  const getHref = () => getProps().href;

  const element = compose(
    'span',
    () => ({
      style: `display: inline-block;
              text-align: center;
              box-sizing: border-box;
              width: 160px;
              height: 40px;
              line-height: 40px;
              font-size: 15px;
              border-bottom: ${getBorderBottom(getIsSelected())};`,
    }),
    [
      compose(
        'a',
        () => ({
          href: getHref(),
          innerText: getProps().label,
          style: `text-decoration: none;
                  display: inline-block;
                  width: 100%;
                  color: ${getColor(isHovered, getIsSelected())};`,
          onmouseenter: () => {
            isHovered = true;
            element.update();
          },
          onmouseleave: () => {
            isHovered = false;
            element.update();
          },
        }),
        []
      ),
    ]
  );
  return element;
};

module.exports = NavigationButton;

  return module.exports;
})();

modules['src/views/project/projectNavigator/dataSourcesButton/DataSourcesButton.js'] = (() => {
  const module = { exports: {} };
  const NavigationButton = include('src/libraries/simpleUI/NavigationButton.js');

const determineIsSelected = (currentRoute) => {
  return [
    '/projects/<projectId:string>',
    '/projects/<projectId:string>/data-sources',
  ].includes(currentRoute);
};

const getHref = (selectedProjectId) => {
  return `#!/projects/${selectedProjectId}/data-sources`;
};

const DataSourcesButton = (getProps) => {
  const getCurrentRoute = () => getProps().state.currentRoute;
  const getSelectedProjectId = () => getProps().state.selectedProjectId;

  const element = NavigationButton(() => ({
    label: 'Data sources',
    isSelected: determineIsSelected(getCurrentRoute()),
    href: getHref(getSelectedProjectId()),
  }));

  return element;
};

module.exports = DataSourcesButton;

  return module.exports;
})();

modules['src/views/project/projectNavigator/dashboardEditorButton/DashboardEditorButton.js'] = (() => {
  const module = { exports: {} };
  const NavigationButton = include('src/libraries/simpleUI/NavigationButton.js');

const determineIsSelected = (currentRoute) => {
  return currentRoute === '/projects/<projectId:string>/dashboard-editor';
};

const getHref = (selectedProjectId) => {
  return `#!/projects/${selectedProjectId}/dashboard-editor`;
};

const DashboardEditorButton = (getProps) => {
  const getCurrentRoute = () => getProps().state.currentRoute;
  const getSelectedProjectId = () => getProps().state.selectedProjectId;

  const element = NavigationButton(() => ({
    label: 'Dashboard editor',
    isSelected: determineIsSelected(getCurrentRoute()),
    href: getHref(getSelectedProjectId()),
  }));

  return element;
};

module.exports = DashboardEditorButton;

  return module.exports;
})();

modules['src/views/project/projectNavigator/dashboardButton/DashboardButton.js'] = (() => {
  const module = { exports: {} };
  const NavigationButton = include('src/libraries/simpleUI/NavigationButton.js');

const determineIsSelected = (currentRoute) => {
  return currentRoute === '/projects/<projectId:string>/dashboard';
};

const getHref = (selectedProjectId) => {
  return `#!/projects/${selectedProjectId}/dashboard`;
};

const DashboardButton = (getProps) => {
  const getCurrentRoute = () => getProps().state.currentRoute;
  const getSelectedProjectId = () => getProps().state.selectedProjectId;

  const element = NavigationButton(() => ({
    label: 'Dashboard',
    isSelected: determineIsSelected(getCurrentRoute()),
    href: getHref(getSelectedProjectId()),
  }));

  return element;
};

module.exports = DashboardButton;

  return module.exports;
})();

modules['src/views/project/projectNavigator/ProjectNavigator.js'] = (() => {
  const module = { exports: {} };
  const DataSourcesButton = include(
  'src/views/project/projectNavigator/dataSourcesButton/DataSourcesButton.js'
);
const DashboardEditorButton = include(
  'src/views/project/projectNavigator/dashboardEditorButton/DashboardEditorButton.js'
);
const DashboardButton = include(
  'src/views/project/projectNavigator/dashboardButton/DashboardButton.js'
);
const { compose } = include('src/libraries/simpleHTML/SimpleHTML.js');

const ProjectNavigator = (getProps) => {
  const element = compose('div', { style: 'height: 40px;' }, [
    DataSourcesButton(getProps),
    DashboardEditorButton(getProps),
    DashboardButton(getProps),
  ]);

  return element;
};

module.exports = ProjectNavigator;

  return module.exports;
})();

modules['src/libraries/observable/Observable.js'] = (() => {
  const module = { exports: {} };
  class Observable {
  constructor(value) {
    // Maybe this can cause an id collision of two observables created almost at the same time
    this._id = `${Math.random()}${+new Date()}`;
    this._value = value;
  }
  emit() {
    window.dispatchEvent(
      new CustomEvent(this._id, {
        detail: this._value,
      })
    );
  }
  get id() {
    return this._id;
  }
  get value() {
    return this._value;
  }
  set value(value) {
    // Maybe this should do a deep compare in case value is an object?
    if (value === this._value) return;
    this._value = value;
    this.emit();
  }
}

module.exports = Observable;

  return module.exports;
})();

modules['src/components/visualization/threeDimVisualization/camera/Camera.js'] = (() => {
  const module = { exports: {} };
  const Observable = include('src/libraries/observable/Observable.js');

const Camera = function({
  target = new Observable([0, 0, 0]),
  horizontalRotation$ = new Observable(0),
  verticalRotation$ = new Observable(0),
  distance$ = new Observabe(100),
  focalLength$ = new Observable(100),
}) {
  this.target = target;
  this.horizontalRotation$ = horizontalRotation$;
  this.verticalRotation$ = new Observable(
    Math.max(Math.min(verticalRotation$.value, Math.PI / 4), -Math.PI / 2)
  );
  this.distance$ = new Observable(
    Math.max(distance$.value, -focalLength$.value / 2)
  );
  this.focalLength$ = focalLength$;
  this.setDistance = distance => {
    this.distance$.value = Math.max(distance, -focalLength$.value / 2);
  };
  this.setVerticalRotation = verticalRotation => {
    this.verticalRotation$.value = Math.max(
      Math.min(verticalRotation, Math.PI / 2),
      -Math.PI / 2
    );
  };
};

module.exports = Camera;

  return module.exports;
})();

modules['src/components/widgetLabel/WidgetLabel.js'] = (() => {
  const module = { exports: {} };
  const { compose } = include('src/libraries/simpleHTML/SimpleHTML.js');

const WidgetLabel = (getProps) => {
  const element = compose(
    'div',
    () => ({
      innerText: getProps().label,
      style: `font-size: 20px;
              margin-top: 20px;
              text-align: center;
              position: absolute;
              width: 100%;
              pointer-events: none;
              user-select: none;`,
    }),
    []
  );
  return element;
};

module.exports = WidgetLabel;

  return module.exports;
})();

modules['src/components/widgetValue/WidgetValue.js'] = (() => {
  const module = { exports: {} };
  const { compose } = include('src/libraries/simpleHTML/SimpleHTML.js');

const WidgetValue = (getProps) => {
  const element = compose(
    'div',
    () => ({
      innerText: Number(getProps().value).toFixed(2),
      style: `font-size: 60px;
              text-align: center;
              width: 100%;
              position: absolute;
              top: 50%;
              transform: translate(0, -50%);`,
    }),
    []
  );
  return element;
};

module.exports = WidgetValue;

  return module.exports;
})();

modules['src/components/widget/valueWidget/ValueWidget.js'] = (() => {
  const module = { exports: {} };
  const WidgetLabel = include('src/components/widgetLabel/WidgetLabel.js');
const WidgetValue = include('src/components/widgetValue/WidgetValue.js');
const { compose } = include('src/libraries/simpleHTML/SimpleHTML.js');

const ValueWidget = (getProps) => {
  const element = compose(
    'span',
    () => ({
      // width = 24 x 20px
      // height = 16 x 20px
      style: `display: inline-block;
              position: relative;
              color: dimgray;
              width: 480px;
              height: 320px;`,
    }),
    [
      WidgetLabel(() => ({ label: getProps().label })),
      WidgetValue(() => ({ value: getProps().value })),
    ]
  );
  return element;
};

module.exports = ValueWidget;

  return module.exports;
})();

modules['src/components/visualization/render/toCenterOfWidget/toCenterOfWidget.js'] = (() => {
  const module = { exports: {} };
  const toCenterOfWidget = ([x, y, z], ctx) => [
  x + ctx.canvas.width / 2,
  y - ctx.canvas.height / 2,
  z,
];

module.exports = toCenterOfWidget;

  return module.exports;
})();

modules['src/components/visualization/render/toPerspective/toPerspective.js'] = (() => {
  const module = { exports: {} };
  const toPerspective = ([x, y, z], d, focalLength) =>
  focalLength
    ? [
        x * (focalLength / (d + focalLength + z)),
        y * (focalLength / (d + focalLength + z)),
        z,
      ]
    : [x, y, z];

module.exports = toPerspective;

  return module.exports;
})();

modules['src/components/visualization/render/toCenterOfStructure/toCenterOfStructure.js'] = (() => {
  const module = { exports: {} };
  const toCenterOfStructure = ([x, y, z], transformedCenterOfStructure) => [
  x - transformedCenterOfStructure[0],
  y - transformedCenterOfStructure[1],
  z - transformedCenterOfStructure[2],
];

module.exports = toCenterOfStructure;

  return module.exports;
})();

modules['src/components/visualization/render/rotate/rotate.js'] = (() => {
  const module = { exports: {} };
  const rotate = ([x, y, z], rx, ry) => {
  const theta = rx;
  const phi = ry;

  const horizontallyRotatedVertex = [
    x * Math.cos(theta) + z * Math.sin(theta),
    y,
    z * Math.cos(theta) - x * Math.sin(theta),
  ];

  return [
    horizontallyRotatedVertex[0],
    horizontallyRotatedVertex[1] * Math.cos(phi) -
      horizontallyRotatedVertex[2] * Math.sin(phi),
    horizontallyRotatedVertex[1] * Math.sin(phi) +
      horizontallyRotatedVertex[2] * Math.cos(phi),
  ];
};

module.exports = rotate;

  return module.exports;
})();

modules['src/components/widget/doRenderVisualization/doRenderVisualization.js'] = (() => {
  const module = { exports: {} };
  const toCenterOfWidget = include(
  'src/components/visualization/render/toCenterOfWidget/toCenterOfWidget.js'
);
const toPerspective = include(
  'src/components/visualization/render/toPerspective/toPerspective.js'
);
const toCenterOfStructure = include(
  'src/components/visualization/render/toCenterOfStructure/toCenterOfStructure.js'
);
const rotate = include('src/components/visualization/render/rotate/rotate.js');

/**
 * @param {number} dx
 * Defines the x coordinate which will be displayed in the center of the
 * visualization
 *
 * @param {number} dy
 * Defines the y coordinate which will be displayed in the center of the
 * visualization
 *
 * @param {number} dz
 * Defines the z coordinate which will be displayed in the center of the
 * visualization
 *
 * @param {number} d
 * Defines the distance from the defined center of the structure, to the
 * camera.
 */
const doRenderVisualization = ({
  surfaces,
  edges,
  ctx,
  center,
  rx = 0,
  ry = 0,
  d = 0,
  focalLength = 0,
}) => {
  // Render the faces
  surfaces.forEach(({ color, points }) => {
    points
      .map((point) => toCenterOfStructure(point, center))
      .map((point) => rotate(point, rx, ry))
      .map((point) => toPerspective(point, d, focalLength))
      .map((point) => toCenterOfWidget(point, ctx))
      .forEach((point, index) => {
        if (index === 0) {
          ctx.beginPath();
          ctx.moveTo(point[0], -point[1]);
          return;
        }
        if (index < points.length - 1) {
          ctx.lineTo(point[0], -point[1]);
          return;
        }
        if (index === points.length - 1) {
          ctx.lineTo(point[0], -point[1]);
          ctx.closePath();
          ctx.fillStyle = color;
          ctx.fill();
          return;
        }
      });
  });

  // Render the edges
  edges.forEach(({ color, points, width }) => {
    // Draw the first vertex
    const startPoint = toCenterOfWidget(
      toPerspective(
        rotate(toCenterOfStructure(points[0], center), rx, ry),
        d,
        focalLength
      ),

      ctx
    );
    const endPoint = toCenterOfWidget(
      toPerspective(
        rotate(toCenterOfStructure(points[1], center), rx, ry),
        d,
        focalLength
      ),
      ctx
    );
    ctx.beginPath();
    ctx.lineCap = 'round';
    ctx.moveTo(startPoint[0], -startPoint[1]);
    ctx.lineTo(endPoint[0], -endPoint[1]);
    ctx.lineWidth = width;
    ctx.strokeStyle = color;
    ctx.stroke();
  });
};

module.exports = doRenderVisualization;

  return module.exports;
})();

modules['src/components/widget/canvas3dWidget/Canvas3dWidget.js'] = (() => {
  const module = { exports: {} };
  const Observable = include('src/libraries/observable/Observable.js');
const Camera = include(
  'src/components/visualization/threeDimVisualization/camera/Camera.js'
);
const doRenderVisualization = include(
  'src/components/widget/doRenderVisualization/doRenderVisualization.js'
);
const WidgetLabel = include('src/components/widgetLabel/WidgetLabel.js');
const { compose } = include('src/libraries/simpleHTML/SimpleHTML.js');

// TODO: Shouldn't there be a label here?
const Canvas3dWidget = (getProps) => {
  const { surfaces, edges, center } = getProps();
  const state = { mouseDown: false };
  const element = compose(
    'canvas',
    {
      height: 320, // 16 x 20px
      width: 480, // 24 x 20px
      style: 'position: absolute;',
    },
    []
  );
  const camera = new Camera({
    horizontalRotation$: new Observable(0),
    verticalRotation$: new Observable(0),
    distance$: new Observable(100),
    focalLength$: new Observable(100),
  });
  const ctx = element.getContext('2d');
  const rerender = () => {
    const { surfaces, edges, center } = getProps();
    ctx.clearRect(0, 0, element.width, element.height);
    doRenderVisualization({
      surfaces,
      edges,
      ctx,
      center,
      rx: camera.horizontalRotation$.value,
      ry: camera.verticalRotation$.value,
      d: camera.distance$.value,
      focalLength: camera.focalLength$.value,
    });
  };
  rerender();
  element.onwheel = (event) => {
    camera.setDistance(camera.distance$.value + event.deltaY / 5);
  };
  window.addEventListener('mousedown', (event) => {
    state.mouseDown = true;
  });
  window.addEventListener(
    'mouseup',
    (element.onmouseup = (event) => {
      state.mouseDown = false;
    })
  );
  element.onmousemove = (event) => {
    if (state.mouseDown) {
      camera.horizontalRotation$.value =
        camera.horizontalRotation$.value - event.movementX / 100;
      camera.setVerticalRotation(
        camera.verticalRotation$.value - event.movementY / 100
      );
    }
  };
  element.update = () => {
    rerender(getProps());
  };
  window.addEventListener(camera.horizontalRotation$.id, () => {
    rerender({ surfaces, edges, center });
  });
  window.addEventListener(camera.verticalRotation$.id, () => {
    rerender({ surfaces, edges, center });
  });
  window.addEventListener(camera.distance$.id, () => {
    rerender({ surfaces, edges, center });
  });
  window.addEventListener(camera.focalLength$.id, () => {
    rerender({ surfaces, edges, center });
  });
  return compose(
    'span',
    () => ({
      // width = 24 x 20px
      // height = 16 x 20px
      style: `display: inline-block;
              position: relative;
              color: dimgray;
              width: 480px;
              height: 320px;`,
    }),
    [WidgetLabel(() => ({ label: getProps().label })), element]
  );
};

module.exports = Canvas3dWidget;

  return module.exports;
})();

modules['src/components/widget/canvas2dWidget/Canvas2dWidget.js'] = (() => {
  const module = { exports: {} };
  const doRenderVisualization = include(
  'src/components/widget/doRenderVisualization/doRenderVisualization.js'
);
const WidgetLabel = include('src/components/widgetLabel/WidgetLabel.js');
const { compose } = include('src/libraries/simpleHTML/SimpleHTML.js');

// TODO: Shouldn't there be a label here?
// getProps::() => { surfaces, edges, id3d, center }
const Canvas2dWidget = (getProps) => {
  const element = compose(
    'canvas',
    () => ({
      height: 320, // 16 x SizeUnit
      width: 480, // 24 x SizeUnit
      style: 'position: absolute;',
    }),
    []
  );
  const ctx = element.getContext('2d');
  const rerender = ({ surfaces, edges, center }) => {
    ctx.clearRect(0, 0, element.width, element.height);
    doRenderVisualization({ surfaces, edges, center, ctx });
  };
  rerender(getProps());
  element.update = () => {
    rerender(getProps());
  };
  return compose(
    'span',
    () => ({
      // width = 24 x 20px
      // height = 16 x 20px
      style: `display: inline-block;
              position: relative;
              color: dimgray;
              width: 480px;
              height: 320px;`,
    }),
    [WidgetLabel(() => ({ label: getProps().label })), element]
  );
};

module.exports = Canvas2dWidget;

  return module.exports;
})();

modules['src/components/widget/Widget.js'] = (() => {
  const module = { exports: {} };
  const Canvas3dWidget = include(
  'src/components/widget/canvas3dWidget/Canvas3dWidget.js'
);
const Canvas2dWidget = include(
  'src/components/widget/canvas2dWidget/Canvas2dWidget.js'
);
const ValueWidget = include('src/components/widget/valueWidget/ValueWidget.js');
const { compose, If } = include('src/libraries/simpleHTML/SimpleHTML.js');

/**
 * getProps: () => ({
 *   type: 'canvas-widget' | 'value-widget';
 *   label: string;
 *   value: number;
 *   surfaces: { color: string, points: [number, number, number][] }[];
 *   edges: [[number, number, number][]];
 *   center: [number, number, number];
 *   is3d: boolean;
 * })
 */
const Widget = (getProps) => {
  const element = compose(
    'span',
    () => ({
      style: `padding: 10px;
              display: inline-block;
              `,
    }),
    [
      compose(
        'span',
        {
          // width = 24 x 20px
          // height = 16 x 20px
          style: `display: inline-block;
                  vertical-align: top;
                  background: white;
                  width: 480px;
                  height: 320px;
                  box-shadow: rgba(0, 0, 0, 0.25) 0 0 10px -5px;`,
        },
        [
          If(
            () => getProps().type === 'canvas-widget',
            () => [
              If(
                () => getProps().is3d,
                () => [Canvas3dWidget(getProps)],
                () => [Canvas2dWidget(getProps)]
              ),
            ]
          ),
          If(
            () => getProps().type === 'value-widget',
            () => [ValueWidget(getProps)]
          ),
        ]
      ),
    ]
  );

  return element;
};

module.exports = Widget;

  return module.exports;
})();

modules['src/components/dashboardWidgets/DashboardWidgets.js'] = (() => {
  const module = { exports: {} };
  const Widget = include('src/components/widget/Widget.js');
const { compose, Each, If } = include('src/libraries/simpleHTML/SimpleHTML.js');

const DashboardWidgets = (getProps) => {
  const element = compose('div', {}, [
    Each(
      () => getProps().state.widgets,
      (getCurrentValue) => [Widget(getCurrentValue)]
    ),
  ]);

  return element;
};

module.exports = DashboardWidgets;

  return module.exports;
})();

modules['src/views/dashboard/Dashboard.js'] = (() => {
  const module = { exports: {} };
  const DashboardWidgets = include(
  'src/components/dashboardWidgets/DashboardWidgets.js'
);
const { compose } = include('src/libraries/simpleHTML/SimpleHTML.js');

const Dashboard = (getProps) => {
  const element = compose('div', { style: `padding: 10px;` }, [
    DashboardWidgets(getProps),
  ]);

  return element;
};

module.exports = Dashboard;

  return module.exports;
})();

modules['src/app/exportedApp/ExportedApp.js'] = (() => {
  const module = { exports: {} };
  const TitleBar = include('src/app/titleBar/TitleBar.js');
const Dashboard = include('src/views/dashboard/Dashboard.js');
const { compose } = include('src/libraries/simpleHTML/SimpleHTML.js');

const ExportedApp = (getProps) => {
  const element = compose('div', {}, [
    TitleBar(getProps),
    compose('div', {}, [Dashboard(getProps)]),
  ]);
  return element;
};

module.exports = ExportedApp;

  return module.exports;
})();

modules['src/views/dashboardEditor/DashboardEditor.js'] = (() => {
  const module = { exports: {} };
  const DashboardWidgets = include(
  'src/components/dashboardWidgets/DashboardWidgets.js'
);
const CodeEditor = include('src/components/codeEditor/CodeEditor.js');
const { compose } = include('src/libraries/simpleHTML/SimpleHTML.js');

const DashboardEditor = (getProps) => {
  const getViewModel = () => getProps().viewModel;
  const getSelectedProjectId = () => getProps().state.selectedProjectId;
  const getSelectedWidgetsCode = () => getProps().state.selectedWidgetsCode;

  const element = compose('div', { style: 'padding: 10px;' }, [
    CodeEditor(() => ({
      value: getSelectedWidgetsCode(),
      oninput: ({ target }) => {
        getViewModel().updateWidgetsCode(getSelectedProjectId(), target.value);
      },
    })),
    DashboardWidgets(getProps),
  ]);

  return element;
};

module.exports = DashboardEditor;

  return module.exports;
})();

modules['src/app/unexportedApp/UnexportedApp.js'] = (() => {
  const module = { exports: {} };
  const ProjectNavigator = include(
  'src/views/project/projectNavigator/ProjectNavigator.js'
);
const TitleBar = include('src/app/titleBar/TitleBar.js');
const Projects = include('src/views/projects/Projects.js');
const DataSources = include('src/views/dataSources/DataSources.js');
const Dashboard = include('src/views/dashboard/Dashboard.js');
const DashboardEditor = include('src/views/dashboardEditor/DashboardEditor.js');

const { compose, If } = include('src/libraries/simpleHTML/SimpleHTML.js');

const isProjectsUrl = (currentRoute) => {
  return currentRoute === '/';
};

const hasOpenedProject = (currentRoute) => {
  return currentRoute.indexOf('/projects/<projectId:string>') === 0;
};

const isDataSourcesUrl = (currentRoute) => {
  return (
    currentRoute === '/projects/<projectId:string>/data-sources' ||
    currentRoute === '/projects/<projectId:string>'
  );
};

const isDashboardEditorUrl = (currentRoute) => {
  return currentRoute === '/projects/<projectId:string>/dashboard-editor';
};

const isDashboardUrl = (currentRoute) => {
  return currentRoute === '/projects/<projectId:string>/dashboard';
};

// getProps::() => { state, viewModel }
const UnexportedApp = (getProps) => {
  const getCurrentRoute = () => getProps().state.currentRoute;
  const element = compose('div', {}, [
    TitleBar(getProps),
    If(
      () => isProjectsUrl(getCurrentRoute()),
      () => [Projects(getProps)]
    ),
    If(
      () => hasOpenedProject(getCurrentRoute()),
      () => [
        compose('div', {}, [
          ProjectNavigator(getProps),
          If(
            () => isDataSourcesUrl(getCurrentRoute()),
            () => [DataSources(getProps)]
          ),
          If(
            () => isDashboardEditorUrl(getCurrentRoute()),
            () => [DashboardEditor(getProps)]
          ),
          If(
            () => isDashboardUrl(getCurrentRoute()),
            () => [Dashboard(getProps)]
          ),
        ]),
      ]
    ),
  ]);

  return element;
};

module.exports = UnexportedApp;

  return module.exports;
})();

modules['src/app/App.js'] = (() => {
  const module = { exports: {} };
  const ExportedApp = include('src/app/exportedApp/ExportedApp.js');
const UnexportedApp = include('src/app/unexportedApp/UnexportedApp.js');

// getProps::() => { state, viewModel }
const App = (getProps) => {
  const element = getProps().state.isExported
    ? ExportedApp(getProps)
    : UnexportedApp(getProps);
  return element;
};

module.exports = App;

  return module.exports;
})();

window.addEventListener('load', () => {
const Router = include('src/libraries/simpleRouter/SimpleRouter.js');
const simpleState = include('src/libraries/simpleState/SimpleState.js');
const Model = include('src/model/Model.js');
const App = include('src/app/App.js');
const { compose } = include('src/libraries/simpleHTML/SimpleHTML.js');

Object.assign(document.body.style, {
  margin: 0,
  fontFamily: 'sans-serif',
  background: 'GhostWhite',
  height: '100%',
});

const isExported = false;

// Create router
const router = isExported
  ? new Router({
      '/': 'Dashboard',
    })
  : new Router({
      '/': 'Projects',
      '/projects/<projectId:string>': 'Data sources',
      '/projects/<projectId:string>/data-sources': 'Data sources',
      '/projects/<projectId:string>/values': 'Values',
      '/projects/<projectId:string>/values/edit': 'Edit values',
      '/projects/<projectId:string>/dashboard': 'Dashboard',
      '/projects/<projectId:string>/dashboard-editor': 'Edit dashboard',
    });

const { state, setState, addStateChangeListener } = simpleState({
  currentRoute: router.currentRoute,
  params: router.params,
  isExported,
  projects: [],
  selectedProjectId: null,
  selectedProjectName: '',
  lastVisitedProjectView: null,
  selectedApiUrl: '',
  selectedApiUrlTestPreview: '',
  selectedApiInterval: null,
  apiResponse: '',
  selectedDerivedValuesCode: '',
  selectedWidgetsCode: '',
  widgets: [],
});

const viewModel = Model({ router, state, setState });

const app = compose('div', {}, [
  App(() => ({
    state,
    setState,
    viewModel,
  })),
]);

addStateChangeListener(app.update);

document.body.appendChild(app);

})
</script>